---
title: "04_Overcrowded.Households"
format: html
editor: visual
---

# 0.0 Setup - Define helper functions, set knitr path, load necessary packages, set muni data keys

```{r}
#===============================================================================
#TODO:
# x. Create a multigenerational variable that is more in line with IPUMS
# x. Create a table creation function
# x. Create a graph creation function
#===============================================================================
```

# 0.1 - Set knitr path + root for inputs

```{r, setup, include=FALSE}
# Use when Rproject is open
# root <- '../../../../Data/Working/Regional_Control_Totals/'

# Base root. Toggle between S: and K: drive depending on mapped paths on your computer
base <- "K:/DataServices/Projects/Current_Projects/"

# General K drive filepath
root <-"K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/Regional_Control_Totals/"

# PUMS K drive filepath
pums_path <- "K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/ipums_2021/"

# Set output filepath
output_path <- "K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/outputs/"

# Reweighter files path
rwt_path <- paste0(base, "Housing/StatewideHousingPlan/04_Analysis/Data/Working/Reweighter/")

# Set knitr path
knitr::opts_knit$set(root.dir = pums_path)
```

# 0.2 - Set package dependencies, set environment, set up data keys

```{r}
library(tidycensus)
library(tidyverse)
library(data.table)
library(mapcdatakeys)
library(janitor)
library(readxl)
library(here)
library(RPostgreSQL)

# Remove scientific notation
options(scipen = 999)
# Set random seed
set.seed(351)

# Load Libraries for PUMS Analysis and PUMS API query functions
# Sets seed and removes scientific notation
source(file = "C:/Project_Work/statewidehousingplan/PUMS_Analysis/PUMS_Helper_Functions.R")
source(file = "C:/Project_Work/Local_Data/General/census.data_connection.R")
source(file = "C:/Project_Work/housing/dbConnections.R")
#source(file = "C:/Project_Work/housing/ami-analysis.R")

# Load PUMA x RPA Crosswalk
xw <- read.csv(paste0(rwt_path, "PUMS_data/PUMA10_RPA_crosswalk.csv")) |> 
  mutate(PUMA = str_pad(PUMA, 5, "left", pad = 0))

# Load MUnicipality to PUMA Crosswalk
muni2puma<-read_csv(paste0(rwt_path, "PUMS_data/pums_muni_inter.csv")) |> 
  select(TOWN_ID, PUMACE10) |> 
  dplyr::rename(muni_id = TOWN_ID)

# 
muni2rpa <- mapcdatakeys::all_muni_data_keys |> select(muni_id, rpa_acr)

# Set PUMS vintage final year for {tidycensus} API query.
vintage <- 2021

# List of PUMS variables
variable_list <- c('RT', 'PUMA', 'ADJHSG','ADJINC','NP','TYPEHUGQ','BDSP','RMSP','CPLT','HHLDRAGEP',
                   'HHLDRRAC1P','HHLDRHISP', 'HHT', 'HHT2', 'HINCP', 'HUGCL', 'HUPAC', 'HUPAOC',
                   'HUPARC', 'LNGI', 'MULTG', 'NPF', 'NPP', 'NR','NRC', 'PARTNER', 'PSF','R18',
                   'AGEP','RELSHIPP','RAC1P','OC','SFN','SFR','TEN', "SEX", "PINCP", "ESR",
                   "MV", "GRPIP", "OCPIP")

# Load PUMS variables
pums <- pums_query(var.list = variable_list, yr = vintage, srvy = "acs5") |> 
  mutate(
    PUMA = as.character(str_pad(PUMA, width = 5, side = "left", pad = 0)),
    puma_id = PUMA
  )



```
# WORK IN PROGRESS - Less Than Elegant AMI Table Generation
```{r}
# Pull AMI Table for 2021
puma.ami_table <- get_mapc_database(
  db.table_name = "hous_section8_income_limits_by_year_m",
  year = 2021,
  vars = "*"
) |>
  mutate(
    #100% AMI
    il_100_1 = il_50_1 * 2,
    il_100_2 = il_50_2 * 2,
    il_100_3 = il_50_3 * 2,
    il_100_4 = il_50_4 * 2,
    il_100_5 = il_50_5 * 2,
    il_100_6 = il_50_6 * 2,
    il_100_7 = il_50_7 * 2,
    il_100_8 = il_50_8 * 2,
    # 40 % AMI
    il40_1 = il_100_1 * 0.4,
    il40_2 = il_100_2 * 0.4,
    il40_3 = il_100_3 * 0.4,
    il40_4 = il_100_4 * 0.4,
    il40_5 = il_100_5 * 0.4,
    il40_6 = il_100_6 * 0.4,
    il40_7 = il_100_7 * 0.4,
    il40_8 = il_100_8 * 0.4,
    # 60 % AMI
    il60_1 = il_100_1 * 0.6,
    il60_2 = il_100_2 * 0.6,
    il60_3 = il_100_3 * 0.6,
    il60_4 = il_100_4 * 0.6,
    il60_5 = il_100_5 * 0.6,
    il60_6 = il_100_6 * 0.6,
    il60_7 = il_100_7 * 0.6,
    il60_8 = il_100_8 * 0.6,
    # 70 % AMI
    il70_1 = il_100_1 * 0.7,
    il70_2 = il_100_2 * 0.7,
    il70_3 = il_100_3 * 0.7,
    il70_4 = il_100_4 * 0.7,
    il70_5 = il_100_5 * 0.7,
    il70_6 = il_100_6 * 0.7,
    il70_7 = il_100_7 * 0.7,
    il70_8 = il_100_8 * 0.7
  ) |>
  left_join(muni2puma,
            by = c("muni_id")) |>
  select(-c(
    municipal,
    muni_id,
    countyname,
    areaname,
    seq_id,
    fy_year,
    median
  )) |>
  group_by(PUMACE10) |>
  mutate(across(starts_with("il"), ~ round(mean(.), 0))) |>
  ungroup() |>
  distinct(PUMACE10, .keep_all = TRUE) |> 
  relocate(PUMACE10) |> 
  dplyr::rename(puma_id = PUMACE10)
  
  # Pull AMI Table for 2021
rpa.ami_table <- get_mapc_database(
  db.table_name = "hous_section8_income_limits_by_year_m",
  year = 2021,
  vars = "*"
) |>
  mutate(
    #100% AMI
    il_100_1 = il_50_1 * 2,
    il_100_2 = il_50_2 * 2,
    il_100_3 = il_50_3 * 2,
    il_100_4 = il_50_4 * 2,
    il_100_5 = il_50_5 * 2,
    il_100_6 = il_50_6 * 2,
    il_100_7 = il_50_7 * 2,
    il_100_8 = il_50_8 * 2,
    # 40 % AMI
    il40_1 = il_100_1 * 0.4,
    il40_2 = il_100_2 * 0.4,
    il40_3 = il_100_3 * 0.4,
    il40_4 = il_100_4 * 0.4,
    il40_5 = il_100_5 * 0.4,
    il40_6 = il_100_6 * 0.4,
    il40_7 = il_100_7 * 0.4,
    il40_8 = il_100_8 * 0.4,
    # 60 % AMI
    il60_1 = il_100_1 * 0.6,
    il60_2 = il_100_2 * 0.6,
    il60_3 = il_100_3 * 0.6,
    il60_4 = il_100_4 * 0.6,
    il60_5 = il_100_5 * 0.6,
    il60_6 = il_100_6 * 0.6,
    il60_7 = il_100_7 * 0.6,
    il60_8 = il_100_8 * 0.6,
    # 70 % AMI
    il70_1 = il_100_1 * 0.7,
    il70_2 = il_100_2 * 0.7,
    il70_3 = il_100_3 * 0.7,
    il70_4 = il_100_4 * 0.7,
    il70_5 = il_100_5 * 0.7,
    il70_6 = il_100_6 * 0.7,
    il70_7 = il_100_7 * 0.7,
    il70_8 = il_100_8 * 0.7
  ) |>
  left_join(muni2rpa,
            by = c("muni_id")) |>
  select(-c(
    municipal,
    muni_id,
    countyname,
    areaname,
    seq_id,
    fy_year,
    median
  )) |>
  group_by(rpa_acr) |>
  mutate(across(starts_with("il"), ~ round(mean(.), 0))) |>
  ungroup() |>
  distinct(rpa_acr, .keep_all = TRUE) |> 
  relocate(rpa_acr)

#===============================================================================
# PUMA-based AMI Tables

full.pums_ami.subsets <- NULL

for (i in 1:8) {
  ami_table_filtered <- puma.ami_table |> 
    select(puma_id, ends_with(as.character(i))) |>  #change to puma id
    # this example below is the correct syntax - also noting that if you don't reorder the table 50 comes before 30
    `colnames<-`(c("puma_id","il30","il50","il80","il100", "il40", "il60", "il70"))
  
  pums_ami.subset <- pums |>
    #account for households larger than 8, will be treated as 8 person
    mutate(size_group = ifelse(NP > 8, 8, NP)) |>
    #run the analysis on just the size household we have the filtered ami table to
    filter(size_group == i) |>
    #join in the ami table of income limits
    left_join(ami_table_filtered, by = "puma_id") |>
    #create a column called ami_group that will assign an ami % to an income based on the PUMA
    mutate(
      ami_group = case_when(
        HINCP <= il30 ~ "u30",
        HINCP <= il40 ~ "e40",
        HINCP <= il50 ~ "e50",
        HINCP <= il60 ~ "e60",
        HINCP <= il70 ~ "e70",
        HINCP <= il80 ~ "e80",
        .default = "o80"
      )
    )
  
  full.pums_ami.subsets <- bind_rows(full.pums_ami.subsets, pums_ami.subset)
  
  rm(ami_table_filtered, pums_ami.subset)
  
  print(paste0("Finished creating a subset of PUMS records with a household size of ", i, "!"))
  
}

ami_summary <- full.pums_ami.subsets |> 
  filter(SPORDER == 1 & TYPEHUGQ == 1) |> 
  group_by(size_group, ami_group) |> 
  summarise(hh = sum(WGTP)) |> 
  ungroup()  |>
  # Percent Calculation for the first Crosstab
  group_by(size_group) |> 
  mutate(
    total_hh.1st.xtab = sum(hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct.1st.xtab = round(hh/total_hh.1st.xtab, digits = 3),
    # Percent Calculation for the second Crosstab
    total_hh.2nd.xtab = sum(hh),
    pct.2nd.xtab = round(hh/total_hh.2nd.xtab, digits = 3)
  )

#===============================================================================
# RPA-based AMI Tables
pums_rpa <- left_join(pums, xw, by = c("PUMA"), relationship = "many-to-many")

rpa_list <- xw |> distinct(rpa_acr) |> pull(rpa_acr)

full.pums_ami.subsets <- NULL

for (j in rpa_list) {
  for (i in 1:8) {
    ami_table_filtered <- rpa.ami_table |>
      select(rpa_acr, ends_with(as.character(i))) |> #change to puma id
      filter(rpa_acr == j) |> 
      # this example below is the correct syntax - also noting that if you don't reorder the table 50 comes before 30
      `colnames<-`(c("rpa_acr","il30","il50","il80","il100", "il40", "il60", "il70"))
    
    pums_ami.subset <- pums_rpa |>
      #account for households larger than 8, will be treated as 8 person
      mutate(size_group = ifelse(NP > 8, 8, NP)) |>
      #run the analysis on just the size household we have the filtered ami table to
      filter(rpa_acr == j & size_group == i) |>
      #join in the ami table of income limits
      left_join(ami_table_filtered, by = "rpa_acr") |>
      #create a column called ami_group that will assign an ami % to an income based on the PUMA
      mutate(
        ami_group = case_when(
          HINCP <= il30 ~ "u30",
          HINCP <= il40 ~ "e40",
          HINCP <= il50 ~ "e50",
          HINCP <= il60 ~ "e60",
          HINCP <= il70 ~ "e70",
          HINCP <= il80 ~ "e80",
          .default = "o80"
        )
      )
    
    full.pums_ami.subsets <-bind_rows(full.pums_ami.subsets, pums_ami.subset)
    
    rm(ami_table_filtered, pums_ami.subset)
    
    print(paste0("Finished creating a subset of PUMS records with a household size of ",i,"!"))
    
  }
  
  print(paste0("Finished creating subset of PUMS records in ", j, "!"))
  
}

```

# WORK IN PROGRESS - Elegant AMI Table Generation Function
```{r}
# 
# ami_aggregations <- function(join_table, agg_param){
#   
#   # Pull AMI Table for 2021
#   ami_table <- get_mapc_database(
#     db.table_name = "hous_section8_income_limits_by_year_m",
#     year = 2021,
#     vars = "*"
#   ) |>
#     mutate(
#       #100% AMI
#       il_100_1 = il_50_1 * 2,
#       il_100_2 = il_50_2 * 2,
#       il_100_3 = il_50_3 * 2,
#       il_100_4 = il_50_4 * 2,
#       il_100_5 = il_50_5 * 2,
#       il_100_6 = il_50_6 * 2,
#       il_100_7 = il_50_7 * 2,
#       il_100_8 = il_50_8 * 2,
#       # 40 % AMI
#       il40_1 = il_100_1 * 0.4,
#       il40_2 = il_100_2 * 0.4,
#       il40_3 = il_100_3 * 0.4,
#       il40_4 = il_100_4 * 0.4,
#       il40_5 = il_100_5 * 0.4,
#       il40_6 = il_100_6 * 0.4,
#       il40_7 = il_100_7 * 0.4,
#       il40_8 = il_100_8 * 0.4,
#       # 60 % AMI
#       il60_1 = il_100_1 * 0.6,
#       il60_2 = il_100_2 * 0.6,
#       il60_3 = il_100_3 * 0.6,
#       il60_4 = il_100_4 * 0.6,
#       il60_5 = il_100_5 * 0.6,
#       il60_6 = il_100_6 * 0.6,
#       il60_7 = il_100_7 * 0.6,
#       il60_8 = il_100_8 * 0.6,
#       # 70 % AMI
#       il70_1 = il_100_1 * 0.7,
#       il70_2 = il_100_2 * 0.7,
#       il70_3 = il_100_3 * 0.7,
#       il70_4 = il_100_4 * 0.7,
#       il70_5 = il_100_5 * 0.7,
#       il70_6 = il_100_6 * 0.7,
#       il70_7 = il_100_7 * 0.7,
#       il70_8 = il_100_8 * 0.7
#     ) |>
#     left_join(
#       join_table,
#       by = c("muni_id")
#     ) |>
#     select(-c(
#       municipal,
#       muni_id,
#       countyname,
#       areaname,
#       seq_id,
#       fy_year,
#       median
#     ))
#   
#   group_list <- ami_table |> pull(ami_table[[agg_param]])
#   
#   aggr.ami_table <- NULL
#   
#   for (i in group_list){
#     tmp <- ami_table |>
#       group_by(ami_table$agg_param[[i]]) |>
#       mutate(across(starts_with("il"), ~ round(mean(.), 0))) |>
#       ungroup() |>
#       relocate(ami_table$agg_param)
#     
#     aggr.ami_table <- bind_rows(aggr.ami_table, tmp)
#     
#   }
#   
#   return(ami_table)
#   
# }
# 
# ami_table.PUMA <- ami_aggregations(muni2puma, agg_param = PUMACE10)
# 
# ami_table.RPA <- ami_aggregations(muni2rpa, agg_param = rpa_acr)

```



# 0.3 PUMS Data Cleaning

```{r}
# General Data Cleaning
pums_cleaned <- pums |> 
  # Create a household flag for whether there is a child in a household.
  mutate(
    # Generate five-year age groupings to match UMDI population projections data.
    ageCAT6 = cut(AGEP, breaks = c(-Inf, seq(4, 84, 5), Inf), labels = 1:18),
    # Create a household flag for whether there is a child (a person under the age of 18) in the household.
    # (1) indicates a person is under the age of 18
    # (0) indicates a person is 18 or older.
    child = case_when(
      AGEP < 18 ~ 1,
      AGEP >= 18 ~ 0,
      .default = 0
    ),
    # Generate ten-year age groupings
    # ageCAT4 is the 2020 decennial census age breaks for age of householder - used for 2020 base year control total reweighter targets
    ageCAT4 = case_when(
      AGEP %in% 0:14 ~ 0,
      AGEP %in% 15:24 ~ 1,
      AGEP %in% 25:34 ~ 2,
      AGEP %in% 35:44 ~ 3,
      AGEP %in% 45:54 ~ 4,
      AGEP %in% 55:59 ~ 5,
      AGEP %in% 60:64 ~ 6,
      AGEP %in% 65:74 ~ 7,
      AGEP %in% 75:84 ~ 8,
      AGEP >= 85 ~ 9,
      .default = 0
    ), 
    # Counts as Worker
    # NOTE: Categories are:
    # (0) under 16 or not in labor force
    # (1) in labor force or non-civilian worker
    worker = case_when(
      # (b) indicates a person under the age of 16.
      # (6) indicates someone not in the laborforce
      (ESR == "b" | ESR == 6) ~ 0,
      # (1) indicates an employed civilian at work.
      # (2) indicates an employed civilian with a job but not at work.
      # (3) indicates civilian who is unemployed.
      # (4) Indicates an employed person in the armed forces. 
      # (5) indicates an employed person in the armed forces with a job but not at work.      
      (ESR == 1 | ESR == 2 | ESR == 3 | ESR == 4 | ESR == 5) ~ 1,
      # When ESR is NA, default to not in the laborforce.
      is.na(ESR) ~ 0,
      # If no information is present default to not in the laborforce.
      .default = 0
    ),
    # Create a grouping variable for types of relationships to the householder.
    # NOTE: 
    # (0) indicates a person in a household that is related in some way to the householder.
    # (1) indicates a person in a household unrelated to the householder.
    RELSHIPP_Group = case_when(
      RELSHIPP %in% c(21,22,23,24,25,26,27,28,29,30,31,32,33) ~ 0,
      RELSHIPP %in% c(34,35,36) ~ 1,
      # Set a default flag for householders.
      .default = 0
    ),
    # Create a grouping variable for owner and renter households.
    TEN_Group = case_when(
      # Owned with a mortage or free and clear -> "Own"
      TEN %in% c("1","2") ~ "Own",
      # Rented or occupied without payment of rent -> "Rent"
      TEN %in% c("3","4") ~ "Rent",
      .default = "Unknown"
    ),
    # Create a "Studio/Non-Defined Bedroom" variable to denote where households do
    # not have a bedroom number.
    studio_flag = case_when(
      BDSP == 0 ~ "Studio/No Defined Bedroom",
      BDSP != 0 ~ "Defined Bedroom",
      .default = "Unknown"
    ),
    # Redefine BDSP to label studios/non-defined bedroom units as One-Bedrooms
    # For purpose of calculating the number of people per bedrooms.
    BDSP = if_else(BDSP == 0, 1, BDSP),
    # Calculate the number of people per bedroom in a housing unit.
    PPB = NP/BDSP,
    # Categorize each housing unit as overcrowded or not based on PPB.
    overcrowded.ppb = case_when(
      PPB > 2.0 ~ "1",
      PPB <= 2.0 ~ "0"
    ),
    # Convert SFN into a numeric column. Introduces NAs for people not in subfamilies
    SFN = as.numeric(SFN),
    # Replace the NA for non-subfamily members with 0.
    SFN = replace_na(SFN, 0),
    # Adjust Household income (HINCP) to constant dollars (USD2021)
    HINCP_adj = HINCP*as.numeric(ADJINC),
    # Household Income Groupings consistent with UrbanSim groupings
    HH.Income_Group = case_when(
      HINCP_adj <= 35000 ~ "<=$35,000",
      HINCP_adj > 35000 & HINCP_adj <= 75000 ~ "$35,001-$75,000",
      HINCP_adj > 75000 & HINCP_adj <= 125000 ~ "$75,001-$125,000",
      HINCP_adj > 125000 & HINCP_adj <= 225000 ~ "$125,001-$225,000",
      HINCP_adj > 225000 ~ ">$225,000",
      .default = "0"
    ),
    # Householder Race Groupings. 
    HHLDRRACE_Group = case_when(
      HHLDRRAC1P == "1" ~ "White Alone",
      HHLDRRAC1P == "2" ~ "Black or African American Alone",
      HHLDRRAC1P %in% c("3", "4", "5") ~ "AIAN Alone",
      HHLDRRAC1P == "6" ~ "Asian Alone",
      HHLDRRAC1P == "7" ~ "NHPI Alone",
      HHLDRRAC1P == "8" ~ "SOR Alone",
      HHLDRRAC1P == "9" ~ "Two or More Races Alone",
      .default = "Unknown"
    ),
    # Householder Latine Groupings
    HHLDRHISP_Group = case_when(
      HHLDRHISP == "01" ~ "Non-Hispanic",
      HHLDRHISP != "01" ~ "Hispanic",
      .default = "Unknown"
    ),
    # Create a flag for whether a person in a household is a roommate or housemate
    roommate_flag = case_when(
      RELSHIPP == 34 ~ 1,
      RELSHIPP != 34 ~ 0,
      .default = 0
    ),
    # Replace any NAs (for households that own and so dont have a GRPIP and vice versa)
    GRPIP = replace_na(GRPIP, 0),
    OCPIP = replace_na(OCPIP, 0),
    # Define a "cost burdened" indicator.
    # (1) A household paying more than 30% of its income in housing costs (GRPIP or OCPIP) is considered "cost burdened"
    # (0) A household paying less than or equal to 30% of its income in housing costs is NOT considered "cost burdened"
    CostBurdened = case_when(
      GRPIP > 30 | OCPIP > 30 ~ "1",
      GRPIP <= 30 | OCPIP <= 30 ~ "0",
      .default = "0"
    )
  ) |>
  # Creating household flags for person variables.
  group_by(SERIALNO) |> 
  mutate(
    # Create a variable which is the sum of the number of children in a household
    Child_Total = sum(child),
    # Sum the total number of workers in the household
    Worker_Total = sum(worker),
    # Create a variable which is the sum of the number of non-relatives in the household
    Non.Relative_Total = sum(RELSHIPP_Group),
    # Create a variable that is the sum of roommates in a household
    Roommate_Total = sum(roommate_flag),
    # Create a column which denotes the presence of subfamilies for a household.
    SFN_Total = sum(SFN),
  ) |> 
  ungroup() |> 
  mutate(
  # Create a variable that indicates whether or not a household has children. 
   child_flag = case_when(
      Child_Total > 0 ~ "1",
      Child_Total == 0 ~ "0",
      .default = "0"
    ),
   # Create a variable that indicates whether or not a household has roommates.
   roommate_flag = case_when(
     Roommate_Total > 0 ~ "1",
     Roommate_Total == 0 ~ "0",
     .default = "0"
   ),
   # Create a household flag for whether or not the household contains a subfamily.
   SFN.flag = if_else(SFN_Total > 0, 1, 0),
   # Create a household flag for presence of a non-relative in the household.
   NONRELATIVE.flag = if_else(Non.Relative_Total > 0, 1, 0),
   # Categorizing worker categories:
   # (0) no workers
   # (1) one worker
   # (2) two workers
   # (3) three or more workers
   WRKHH = case_when(
     Worker_Total == 0 ~ 0,
     Worker_Total == 1 ~ 1,
     Worker_Total == 2 ~ 2,
     Worker_Total >= 3 ~ 3
    ),
   # Determine if person is not hhder vs hhder of:
   # (0) No Workers
   # (1) One Worker
   # (2) Two Workers
   # (3) Three or more workers
   HHder = case_when(
     SPORDER == 1 & WRKHH == 0 ~ 0,
     SPORDER == 1 & WRKHH == 1 ~ 1,
     SPORDER == 1 & WRKHH == 2 ~ 2,
     SPORDER == 1 & WRKHH == 3 ~ 3,
     SPORDER > 1 ~ 99
   ), 
   # Determine what type of household the person is heading or not heading:
   # (1) Householder of Household with Children
   # (2) Non-Householder in a Household with Children 
   # (3) Householder of a Household with Multiple Adults and no children 
   # (4) Non-Householder in a Household with no children
   # (5) Householder of a Single Person Household
   HHtype = case_when(
     Child_Total >= 1 & NP > 1 & HHder != 99 ~ 1,
     Child_Total >= 1 & NP > 1 & HHder == 99 ~ 2,
     Child_Total == 0 & NP > 1 & HHder != 99 ~ 3,
     Child_Total == 0 & NP > 1 & HHder == 99 ~ 4,
     NP == 1 & HHder != 99 ~ 5
   )
  ) |> 
  mutate(
    # Non-multigenerational household WITH at least one (1) subfamily WITH at least one (1) child
    subset.flag.1 = case_when(
      MULTG == 1 & SFN.flag > 0 & child_flag > 0 ~ 1,
      .default = 0
    ),
    # Multigenerational households WITH at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.2 = case_when(
      MULTG == 2 & SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    ),
    # Households with at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.3 = case_when(
      SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    )
  )

# Create a subset of the PUMS file for 
pums.subset.1 <- pums_cleaned |> 
  filter(subset.flag.1 == 1)

# And write to the subset as a .csv
write.csv(
  pums.subset.1,
  paste0(output_path, "pums.HRAdj.subset.1.csv"),
  row.names = FALSE
)

# Create a subset of the PUMS file for
pums.subset.2 <- pums_cleaned |> 
  filter(subset.flag.2 == 1)

# And write to the subset as a .csv
write.csv(
  pums.subset.2,
  paste0(output_path, "pums.HRAdj.subset.2.csv"),
  row.names = FALSE
)

# Create a subset of the PUMS file for
pums.subset.3 <- pums_cleaned |> 
  filter(subset.flag.3 == 1)

# And write to the subset as a .csv
write.csv(
  pums.subset.3,
  paste0(output_path, "pums.HRAdj.subset.3.csv"),
  row.names = FALSE
)

# Remove subset files
rm(pums.subset.1, pums.subset.2, pums.subset.3)

```

# 1.0 PUMS Analysis

# 1.1 Overcrowding (PPB) at the State-level and for family households and by number of bedrooms

```{r}
#===============================================================================
# 1.1.1 Overcrowding in general at the State-level
OC.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/sum(oc.hh)
  )

# Write the output to csv
write.csv(
  OC.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.PPB.StateLevel.csv"),
  row.names = FALSE
)

#===============================================================================
#1.1.2 Overcrowding by Family Status at the State-Level
OC.FAMILY.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    child_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    child_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  ) |>
  select(
    -c(hh)
  )

# Write the output to csv
write.csv(
  OC.FAMILY.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.Child.PPB.StateLevel.csv"),
  row.names = FALSE
)

#===============================================================================
# 1.1.3 Overcrowding by Number of Bedrooms
OC.BDRMS.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    BDSP,
    studio_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    BDSP,
    studio_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write the output to csv
write.csv(
  OC.BDRMS.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.BDRMS.PPB.StateLevel.csv"),
  row.names = FALSE
)
```

# 1.2 Overcrowding (PPB) at the RPA-level and for Family households and by Number of Bedrooms

```{r}
#===============================================================================
# 1.2.1 Overcrowding by RPA
OC.RPA.PPB <- pums_cleaned |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    rpa_acr
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.RPA.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.PPB.RPALevel.csv"),
  row.names = FALSE
)

#===============================================================================
# 1.2.2 Overcrowding by RPA and family households
OC.FAMILY.RPA.PPB <- pums_cleaned |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    rpa_acr,
    child_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    child_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.FAMILY.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.Child.PPB.RPALevel.csv"),
  row.names = FALSE
)

#===============================================================================
# 1.2.3 Overcrowding by Number of Bedrooms and RPA
OC.BDRMS.RPA.PPB <- pums_cleaned |> 
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    rpa_acr,
    BDSP,
    studio_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    rpa_acr,
    BDSP,
    studio_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.BDRMS.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.BDRMS.PPB.RPALevel.csv"),
  row.names = FALSE
)

```

# 1.3 General Analysis

About 1.8 percent of households (48,725 households) across the state are overcrowded, which is classified as having more than two persons per bedroom in a given household. Family households (households with a child under 18 years old) have a higher proportion of households which are overcrowded - 5.4 percent (41,501 households). Regarding overcrowding by the number of bedrooms in a household, I expect the proportion of overcrowded households to decrease as the number of bedrooms increases. This is confirmed by the data. 4.9 percent (17,558 households) and 5.1 percent (3,731 households) of one bedrooms and studios, respectively, are overcrowded. The proportion of overcrowded households drops to 2.4 percent for two bedroom households and further to 0.8 percent for households with three bedrooms.The trend follows for households with more bedrooms. A point to delve further on is the incidence of overcrowding in one bedroom and studio units. The Census doesn't singularly define studio units, I've classified them as units where the number of rooms equals one and the number of bedrooms is zero (as opposed to a one bedroom unit where there is one bedroom and at least one room).

When looking at the proportion of overcrowded households by RPA clear differences arise across the state. The Berkshires, Cape Code, Martha's Vineyard and Nantucket all have less than one percent of their households be overcrowded. MAPC has the highest percentage of overcrowded households across all RPA regions with 2.1 percent of households being overcrowded. The other RPAs fall closer to the statewide proportion.

# 2.0 Subfamilies Analysis

A subfamily is defined as either 1) a married couple without children or a 2) single parent with unmarried children under the age of 18. Does not differentiate between whether members of a subfamily are related to the householder. The "RELSHIP" variable contains information about the relatedness of people in a household to the householder. (Source: https://www.census.gov/programs-surveys/cps/technical-documentation/subject-definitions.html#subfamily)

# 2.1 Looking at Composition of Subfamilies to determine if they make sense

```{r}
```

# 2.2 Overcrowded Households by Presence of Subfamilies

```{r}
#===============================================================================
# 2.2.1 Overcrowding by Presence of a Subfamily
OC.SF.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    SFN.flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    SFN.flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.SF.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.SF.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 2.2.2 Overcrowding by Number of Subfamilies
OC.NumSF.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    SFN_Total,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    SFN_Total
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.NumSF.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.NumSF.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 2.2.3 Overcrowding by RPA and Presence of a Subfamily
OC.SF.RPA.PPB <- pums_cleaned |> 
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |>
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    SFN.flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    SFN.flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.SF.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.SF.PPB.RPAlevel.csv"),
  row.names = FALSE
)

#===============================================================================
# 2.2.4 Overcrowding by RPA and Number of Subfamilies
OC.NumSF.RPA.PPB <- pums_cleaned |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |>
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    SFN_Total,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    SFN_Total
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.NumSF.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.NumSF.PPB.RPAlevel.csv"),
  row.names = FALSE
)

```

# 2.3 Subfamily Analysis

Presence of a subfamily (see definition) is associated with a greater proportion of households being over crowded. Only 1.5 percent of households without a subfamily are overcrowded compared to 10.5 percent of households with a subfamily present. One would expect as the *number* of subfamilies in a household increases (a proxy for number of people since at least two people constitute a subfamily) the proportion of households which are overcrowded would also increase. Our expectation is validated in the data -- nine percent (9%) of households with one subfamily are overcrowded, 47% of households with two subfamilies are overcrowded, and *all* households with three subfamilies are overcrowded. This is consistent across RPA regions.

# 3.0 Multigenerational Household Analysis

U.S. Census defines "multigenerational" households as those with three or more generations present in the household.

A second definition is more expansive, one which IPUMS has coded into their microdata sample. They record the number of generations present among people in the household relative to the householder. A household where the parents of the householder live with them would be a two generation household. One where the grandparents, children, and grandchildren are present would be a four generation household. (Source that refers to this definition: https://www2.census.gov/library/publications/2012/acs/acsbr11-03.pdf)

# 3.1 Redefining Multigenerational households

```{r}
# pums_ <- pums_cleaned |> 
#   mutate(
#     #Create a variable that categorizes people into "generations" by their relationship
#     #to the householder
#     GEN = case_when(
#       #
#       
#     )
#   )
```

# 3.2 Overcrowding by Presence of Multiple Generations in a Household (Census Definition)

```{r}
#===============================================================================
# 3.2.1 Overcrowding by Multigenerational Households (Census Definition)
OC.MULTG.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    MULTG,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    MULTG
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 3.2.2 Overcrowding by RPA and Multigenerational Households (Census Definitions)
OC.MULTG.RPA.PPB <- pums_cleaned |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    MULTG,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    MULTG
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.PPB.RPAlevel.csv"),
  row.names = FALSE
)

# Analysis:
```

# 3.3 Analysis:

A far greater proportion of households formed of people from multiple generations are overcrowded (9.9%) than non-multigenerational households (1.4%). The latter group is more similar to the statewide proportion of overcrowded households (1.57%). This is consistent across each of the 13 RPA regions.

# 4.0 Cross-Tabulations

# 4.1 Multigenerational Households and Presense of Subfamilies

```{r}
#===============================================================================
# 4.1.1 Overcrowding by Multigenerational Households (Census Definition) and Presence of Subfamily
OC.MULTG.SF.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    MULTG,
    SFN.flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    MULTG,
    SFN.flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.SF.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.SF.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 4.1.2 Overcrowding by RPA and Multigenerational Households (Census Definitions) and Presence of Subfamily
OC.MULTG.SF.RPA.PPB <- pums_cleaned |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |>  
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    MULTG,
    SFN.flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    MULTG,
    SFN.flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.SF.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.SF.PPB.RPAlevel.csv"),
  row.names = FALSE
)

#===============================================================================
# 4.1.3 Overcrowding by RPA and Multigenerational Households (Census Definitions) and Presence of Subfamily and Presence of Children
OC.MULTG.SF.Child.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    MULTG,
    SFN.flag,
    child_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    MULTG,
    SFN.flag,
    child_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.SF.Child.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.SF.Child.PPB.RPAlevel.csv"),
  row.names = FALSE
)

#===============================================================================
# 4.1.4 Overcrowding and Multigenerational Households (Census Definitions) and Number of Subfamilies
OC.MULTG.NumSF.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    MULTG,
    SFN_Total,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    MULTG,
    SFN_Total
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.NumSF.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.NumSF.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 4.1.5 Overcrowding by RPA and Multigenerational Households (Census Definitions) and Number of Subfamilies and Presence of Children
OC.MULTG.NumSF.Child.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    MULTG,
    SFN_Total,
    child_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    MULTG,
    SFN_Total,
    child_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.NumSF.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.NumSF.Child.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 4.1.6 Overcrowding and Multigenerational Households (Census Definitions) and Number of Subfamilies by RPA
OC.MULTG.NumSF.RPA.PPB <- pums_cleaned |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    MULTG,
    SFN_Total,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    MULTG,
    SFN_Total
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.NumSF.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.NumSF.RPAlevel.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 4.1.7 Overcrowding by RPA and Multigenerational Households (Census Definitions) and Number of Subfamilies and Presence of Children by RPA
OC.MULTG.NumSF.Child.RPA.PPB <- pums_cleaned |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    MULTG,
    SFN_Total,
    child_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    MULTG,
    SFN_Total,
    child_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

# Write output to csv
write.csv(
  OC.MULTG.NumSF.Child.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.NumSF.Child.RPAlevel.PPB.csv"),
  row.names = FALSE
)

```

# 4.2 Analysis:

At the state level

Households that are not multigenerational but contain a subfamily have the highest rate of overcrowding at 11.0% There is nearly no difference in the rate of overcrowding between multigenerational households that contain subfamilies and those that do not (in both sets of households the rate of overcrowding is 9.9%).

What is a reasonable rate of overcrowding? And by that I mean - what is the number of households and the percentage of households that are overcrowded that represent a state where the choice to cohabit with other people, despite having less room, more desirable than living separately. Can we parse out who would rather be living separately from other people in their household if they could choose to do so?

Reasonable rate Non-multigenerational households without the presence of subfamilies

From there

# 5.0 Single Variate Crosstabs and Visualizations

# 5.1 Tenure

```{r}
#===============================================================================
# 5.1 Overcrowding by Tenure at the State-Level
OC.TEN.PPB <- pums_cleaned |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    TEN_Group,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    TEN_Group
  ) |> 
  # Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
  # Create a percent of overcrowded and non-overcrowded households within each crosstab group.
  # Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Create a visualization of the table created above
BG.OC.TEN.PPB <- OC.TEN.PPB |> 
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = TEN_Group, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  #scale_x_discrete(limits = rev) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Renter Households are More Likely to be Overcrowded than Owner Households",
    x = "Tenure",
    y = "Percent of Households Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# View the table created above
BG.OC.TEN.PPB

# Save the visualization created above
ggsave(
  filename = "BG.OC.TEN.PPB.jpeg",
  plot = BG.OC.TEN.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)

# Write the output to csv
write.csv(
  OC.TEN.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.TEN.Statelevel.PPB.csv"),
  row.names = FALSE
)

#===============================================================================
# 5.2 Overcrowding by Tenure at the RPA-Level
OC.TEN.RPA.PPB <- pums_cleaned  |>
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  ) |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    TEN_Group,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    rpa_acr
  ) |> 
  # Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  # Create a percent of overcrowded and non-overcrowded households within each crosstab group.
  # Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.TEN.RPA.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.TEN.RPAlevel.PPB.csv"),
  row.names = FALSE
)

```

# 5.2 Income Groups

```{r}
#===============================================================================
# 5.2 Overcrowding by Income Groups at the State-Level
OC.INC.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    HH.Income_Group,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    HH.Income_Group
  ) |> 
  # Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
  # Create a percent of overcrowded and non-overcrowded households within each crosstab group.
  # Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.INC.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.INC.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Use this list to set the order of the income groups in the bar graph
level_order <- c("<=$35,000", "$35,001-$75,000", "$75,001-$125,000", "$125,001-$225,000", ">$225,000")

# Creates a bar graph of using the dataframe created above.
BG.OC.INC.PPB <- OC.INC.PPB |> 
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = factor(HH.Income_Group, level_order), y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Middle Income Housheolds are more Often Overcrowded",
    x = "Income Group",
    y = "Percent of Overcrowded Households"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.INC.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.INC.PPB.jpeg",
  plot = BG.OC.INC.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)

```

# 5.3 Race Groups

```{r}
#===============================================================================
# 5.3 Overcrowding by Household Race Groups at the State-Level
OC.HHLDERRACE.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    HHLDERRACE_Group,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    HHLDERRACE_Group
  ) |> 
  # Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
  # Create a percent of overcrowded and non-overcrowded households within each crosstab group.
  # Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.HHLDERRACE.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.HHLDERRACE.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Creates a bar graph of using the dataframe created above.
BG.OC.HHLDER_RACE.PPB <- OC.HHLDER_RACE.PPB |>
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = HHLDER.RACE.Grp, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Non-White Households are More Often Overcrowded",
    x = "Race of Householder",
    y = "Percent of Households Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.HHLDER_RACE.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.HHLDER_RACE.PPB.jpeg",
  plot = BG.OC.HHLDER_RACE.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)
```

# 5.4 Presence of Non-Relatives in a Household

```{r}
#===============================================================================
# 5.4 Overcrowding by Presence of Nonrelatives at the State-Level
OC.NONRELATE.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    NONRELATIVE.flag,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    NONRELATIVE.flag
  ) |> 
  # Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
  # Create a percent of overcrowded and non-overcrowded households within each crosstab group.
  # Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.NONRELATE.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.NONRELATE.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Creates a bar graph of using the dataframe created above.
BG.OC.NONRELATE.PPB <- OC.NONRELATE.PPB |> 
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = NONRELATIVE.flag, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_x_discrete(limits = c(0,1)) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Households with Non-Relatives are More Often Overcrowded",
    x = "Presence of a Non-Relative in the Household",
    y = "Percent of Households Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.NONRELATE.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.NONRELATE.PPB.jpeg",
  plot = BG.OC.NONRELATE.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)

```

# 5.5 Ethnicity Group

```{r}
#===============================================================================
# 5.5 Overcrowding by Ethnicity Groups at the State-Level
OC.HHLDERHISP.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    HHDERHISP_Group,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    HHDERHISP_Group
  ) |> 
# Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
# Create a percent of overcrowded and non-overcrowded households within each crosstab group.
# Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.HHLDERHISP.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.HHLDERHISP.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Creates the bar graph for the above table
BG.OC.HHLDER_HISP.PPB <- OC.HHLDER_HISP.PPB |> 
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = HHDER.HISP.Grp, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Hispanic Households are More Often Overcrowded",
    x = "Ethnicity of Householder",
    y = "Percent of Households Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.HHLDER_HISP.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.HHLDER_HISP.PPB.jpeg",
  plot = BG.OC.HHLDER_HISP.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)
```

# 5.6 Number of Children in a Household

```{r}
#===============================================================================
# 5.6 Overcrowding by Number of Children at the State-Level
OC.NumChildren.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    Child_Total,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    Child_Total
  ) |> 
# Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
# Create a percent of overcrowded and non-overcrowded households within each crosstab group.
# Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.NumChildren.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.NumChildren.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Creates the bar graph for the above table
BG.OC.NumChildren.PPB <- OC.NumChildren.PPB |> 
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = Child_Total, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Households with 3-4 and 5-7 Children Experience Jumps in Being Overcrowded",
    x = "Number of Children in a Household",
    y = "Percent of Households which are Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.NumChildren.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.NumChildren.PPB.jpeg",
  plot = BG.OC.NumChildren.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)
```

# 5.7 Time Household Moved into Unit
# Questions: Are older housing units bigger/have more rooms or bedrooms?
# Question: When did people move into units of certain sizes?
# Question: Do people move i

```{r}
#===============================================================================
# 5.7 Overcrowding by Time Moved into Housing Unit at the State-Level
OC.MV.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    MV,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    MV
  ) |> 
# Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
# Create a percent of overcrowded and non-overcrowded households within each crosstab group.
# Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.MV.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.MV.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Creates the bar graph for the above table
BG.OC.MV.PPB <- OC.MV.PPB |> 
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = MV, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Households with 3-4 and 5-7 Children Experience Jumps in Being Overcrowded",
    x = "When a Person Moved into a Housing Unit",
    y = "Percent of Households which are Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.MV.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.MV.PPB.jpeg",
  plot = BG.OC.MV.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)

```

# 5.8 Household Type

```{r}
#===============================================================================
# 5.8 Overcrowding by Household Type at the State-Level
OC.HHtype.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    HHtype,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    HHtype
  ) |> 
# Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
# Create a percent of overcrowded and non-overcrowded households within each crosstab group.
# Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.HHtype.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.HHtype.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Creates the bar graph for the above table
BG.OC.HHtype.PPB <-OC.HHtype.PPB |> 
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = HHtype, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Households with Children are More Likely to Overcrowded Than Any Other Household Type",
    x = "Household Type",
    y = "Percent of Households which are Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.HHtype.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.HHtype.PPB.jpeg",
  plot = BG.OC.HHtype.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)

```

# 5.9 Cost-Burden

```{r}
#===============================================================================
# 5.9 Overcrowding by Housing Cost Burdened Status at the State-Level
OC.CostBurdened.PPB <- pums_cleaned |> 
  # Filters dataframe to households (non-group quarters units) and householders.
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    CostBurdened,
    overcrowded.ppb
  ) |> 
  # Calculates the number of overcrowded and non-overcrowded households in each crosstab group.
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    CostBurdened
  ) |> 
# Calculates the total number of households in the crosstab group (OC + Non-OC)
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |>
# Create a percent of overcrowded and non-overcrowded households within each crosstab group.
# Round to three digits.
  mutate(
    pct = round(oc.hh/hh, digits = 3)
  )

# Write the output to csv
write.csv(
  OC.CostBurdened.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.OC.CostBurdened.Statelevel.PPB.csv"),
  row.names = FALSE
)

# Creates the bar graph for the above table
BG.OC.CostBurdened.PPB <- OC.CostBurdened.PPB |> 
  # Filter for the overcrowded aggregates.
  filter(overcrowded.ppb == "1") |> 
  ggplot(aes(x = CostBurdened, y = pct)) +
  geom_bar(stat = "identity", color = "black", fill = "steelblue") +
  geom_text(aes(label = scales::percent(pct)), vjust = -0.3, size = 3.5) +
  scale_y_continuous(label = scales::percent) +
  labs(
    title = "Households with Children are More Likely to Overcrowded Than Any Other Household Type",
    x = "Cost Burdened Status",
    y = "Percent of Households which are Overcrowded"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(color = "black"),
    axis.text.y = element_text(color = "black")
  )

# Print the bar graph created above.
BG.OC.CostBurdened.PPB

# Save an image of the bar graph created above.
ggsave(
  filename = "BG.OC.CostBurdened.PPB.jpeg",
  plot = BG.OC.CostBurdened.PPB,
  device = "jpeg",
  path = output_path,
  width = 10,
  height = 7,
  units = "in",
  dpi = 300
)
```

# 5.10 AMI-Levels

```{r}
```
