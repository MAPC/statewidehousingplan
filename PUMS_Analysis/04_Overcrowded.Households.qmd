---
title: "04_Overcrowded.Households"
format: html
editor: visual
---

# 0.0 Setup - Define helper functions, set knitr path, load necessary packages, set muni data keys

#0.1 - Set knitr path + root for inputs
```{r, setup, include=FALSE}
#Use when Rproject is open
#root <- '../../../../Data/Working/Regional_Control_Totals/'

#General K drive filepath
root <-"K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/Regional_Control_Totals/"

#PUMS K drive filepath
pums_path <- "K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/"

#Set output filepath
output_path <- "K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/outputs/"

#Set knitr path
knitr::opts_knit$set(root.dir = pums_path)
```

# 0.2 - Set package dependencies, set environment, set up data keys
```{r}
#Load Libraries for PUMS Analysis and PUMS API query functions
#sets seed and removes scientific notation
source("C:/Project_Work/statewidehousingplan/PUMS_Analysis/PUMS_Helper_Functions.R")

#Load PUMS variables
pums <- read.csv(paste0(pums_path,"pums_overcrowding_2021_V_2024-08-19.csv")) |> 
  mutate(
    PUMA = as.character(str_pad(PUMA, width = 5, side = "left", pad = 0))
  )

```

0.3 PUMA to RPA Crosswalk
```{r}
#Set up datakeys for future joins.
mkeys <- mapcdatakeys::all_muni_data_keys |>  select(muni_id,rpa_acr,mpo)

#Load in the municipality to PUMA crosswalk.
psf <- fread(paste0(root,'ma_muni_puma10_join.csv')) |>
  dplyr::rename(
    muni_id=TOWN_ID,
    PUMA = PUMACE10
  ) |>
  left_join(
    mkeys,
    by = c('muni_id')
  ) |>
  setDT()

#Generate RPA to PUMA crosswalk.
lsf <- psf[,lapply(.SD,sum,na.rm=T),.(rpa_acr,PUMA),.SDcols='Shape_Area']
lsf[,mx:=max(Shape_Area),PUMA]
xw <- lsf[Shape_Area==mx, .(rpa_acr,PUMA)]
xw[,PUMA:=sprintf("%05d",PUMA)]

#Manufacturing MVC and NPEDC RPAs manually
#Create an empty matrix with 2x1 dimenstions
matrix <- matrix(nrow = 1, ncol = 2)
#Set the column names to match the PUMA to RPA/MPO crosswalk
col_names <- c("rpa_acr", "PUMA")

#Create dataframes with matrix dimensions for both RPAs
mvc <- data.frame(matrix = matrix)
npedc <- data.frame(matrix = matrix)

#Assign column names to the dataframes
colnames(mvc) <- col_names
colnames(npedc) <- col_names

#Populate data into the MVC and MPEDC dataframes
mvc[[1]] <- "MVC"
mvc[[2]] <- "04800"
npedc[[1]] <- "NPEDC"
npedc[[2]] <- "04800"

#Append MVC and NPEDC data to PUMA to RPA/MPO crosswalk
xw <- bind_rows(xw, mvc, npedc)

#Remove intermediate dataframes.
rm(matrix, col_names, mvc, npedc)
gc()

#Joing the PUMA to RPA crosswalk to the PUMS data.
pums <- left_join(
  pums,
  xw,
  by = c("PUMA")
)
```

# 1.0 PUMS Analysis
# 1.1.1 Total Households by RPA
```{r}
#Calculate the total number of households across the state
tot.hh <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  summarise(
    hh = sum(WGTP)
  )

#Calculate the total number of households in each RPA
tot.hh.rpa <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    rpa_acr
  ) |> 
  summarise(
    hh = sum(WGTP)
  ) |> 
  ungroup()
```

# 1.2.1 Number of People per Bedroom
```{r}
# Finding the number of people and bedrooms in each housing unit
PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  select(SERIALNO, rpa_acr, WGTP, BDSP, NP) |> 
  mutate(
    #Create a "Studio/Non-Defined Bedroom" variable to denote where households do
    #not have a bedroom number.
    studio_flag = case_when(
      BDSP == 0 ~ "Studio/No Defined Bedroom",
      BDSP != 0 ~ "Defined Bedroom",
      .default = "Unknown"
    ),
    #Redefine BDSP to label studios/non-defined bedroom units as One-Bedrooms
    #For purpose of calculating the number of people per bedrooms.
    BDSP = if_else(BDSP == 0, 1, BDSP)
  ) |> 
  group_by(
    rpa_acr,
    SERIALNO,
    studio_flag,
    BDSP,
    NP
  ) |> 
  summarise(
    households = sum(WGTP)
  ) |> 
  ungroup() |> 
  mutate(
    #Calculate the number of people per bedroom in a housing unit.
    PPB = NP/BDSP,
    #Categorize each housing unit as overcrowded or not based on PPB.
    overcrowded.ppb = case_when(
      PPB > 2.0 ~ "1",
      PPB <= 2.0 ~ "0"
    )
  )

```
# 1.2.2 Overcrowding (PPB) at the State-level
```{r}
```

# 1.2.3 Overcrowding (PPB) at the RPA-level
```{r}
```

# 1.3.1 Number of People per Room in a Housing Unit
```{r}
#Number of people per room in the housing unit
PPR <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  select(SERIALNO, rpa_acr, WGTP, RMSP, NP) |> 
  group_by(
    rpa_acr,
    SERIALNO,
    RMSP,
    NP
  ) |> 
  summarise(
    households = sum(WGTP)
  ) |> 
  ungroup() |> 
  mutate(
    #Calculate the number of people per room in a housing unit.
    PPR = NP/RMSP,
    #Categorize each housing unit as overcrowded or not (based on PPR).
    overcrowded.ppr = case_when(
     PPR > 1.5 ~ "1",
     PPR <= 1.5 ~ "0"
    )
  )

```

# 1.3.2 Overcrowding (PPR) at the State-level
```{r}
```

# 1.3.3 Overcrowding (PPR) at the RPA-level
```{r}
#Overcrowding by RPA
OC.RPA.PPR <- PPR |> 
  group_by(
    rpa_acr,
    overcrowded.ppr
  ) |> 
  summarise(
    oc.hh = sum(households)
  ) |> 
  ungroup() |> 
  left_join(
    tot.hh.rpa,
    by = c("rpa_acr")
  ) |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

print(sum(OC.RPA.PPR$households))

#Overcrowding by Number of Rooms in Housing Units
OC.RPA.RMSP.PPR <- PPR |> 
  group_by(
    rpa_acr,
    RMSP,
    overcrowded.ppr
  ) |> 
  summarise(
    oc.hh = sum(households)
  ) |> 
  ungroup()
```

