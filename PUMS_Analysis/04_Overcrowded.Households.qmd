---
title: "04_Overcrowded.Households"
format: html
editor: visual
---

# 0.0 Setup - Define helper functions, set knitr path, load necessary packages, set muni data keys

#0.1 - Set knitr path + root for inputs

```{r, setup, include=FALSE}
#Use when Rproject is open
#root <- '../../../../Data/Working/Regional_Control_Totals/'

#General K drive filepath
root <-"K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/Regional_Control_Totals/"

#PUMS K drive filepath
pums_path <- "K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/"

#Set output filepath
output_path <- "K:/DataServices/Projects/Current_Projects/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/outputs/"

#Set knitr path
knitr::opts_knit$set(root.dir = pums_path)
```

# 0.2 - Set package dependencies, set environment, set up data keys

```{r}
#Load Libraries for PUMS Analysis and PUMS API query functions
#sets seed and removes scientific notation
source("C:/Project_Work/statewidehousingplan/PUMS_Analysis/PUMS_Helper_Functions.R")

#Load PUMS variables
pums <- read.csv(paste0(pums_path,"pums_overcrowding_2021_V_2024-08-19.csv")) |> 
  mutate(
    PUMA = as.character(str_pad(PUMA, width = 5, side = "left", pad = 0))
  )

```

0.3 PUMA to RPA Crosswalk

```{r}
#Set up datakeys for future joins.
mkeys <- mapcdatakeys::all_muni_data_keys |>  select(muni_id,rpa_acr,mpo)

#Load in the municipality to PUMA crosswalk.
psf <- fread(paste0(root,'ma_muni_puma10_join.csv')) |>
  dplyr::rename(
    muni_id=TOWN_ID,
    PUMA = PUMACE10
  ) |>
  left_join(
    mkeys,
    by = c('muni_id')
  ) |>
  setDT()

#Generate RPA to PUMA crosswalk.
lsf <- psf[,lapply(.SD,sum,na.rm=T),.(rpa_acr,PUMA),.SDcols='Shape_Area']
lsf[,mx:=max(Shape_Area),PUMA]
xw <- lsf[Shape_Area==mx, .(rpa_acr,PUMA)]
xw[,PUMA:=sprintf("%05d",PUMA)]

#Manufacturing MVC and NPEDC RPAs manually
#Create an empty matrix with 2x1 dimenstions
matrix <- matrix(nrow = 1, ncol = 2)
#Set the column names to match the PUMA to RPA/MPO crosswalk
col_names <- c("rpa_acr", "PUMA")

#Create dataframes with matrix dimensions for both RPAs
mvc <- data.frame(matrix = matrix)
npedc <- data.frame(matrix = matrix)

#Assign column names to the dataframes
colnames(mvc) <- col_names
colnames(npedc) <- col_names

#Populate data into the MVC and MPEDC dataframes
mvc[[1]] <- "MVC"
mvc[[2]] <- "04800"
npedc[[1]] <- "NPEDC"
npedc[[2]] <- "04800"

#Append MVC and NPEDC data to PUMA to RPA/MPO crosswalk
xw <- bind_rows(xw, mvc, npedc)

#Remove intermediate dataframes.
rm(matrix, col_names, mvc, npedc)
gc()


```

# 0.4 PUMS Data Cleaning

```{r}
#Joing the PUMA to RPA crosswalk to the PUMS data.
pums <- left_join(
  pums,
  xw,
  by = c("PUMA")
)

#General Data Cleaning
pums <- pums |> 
  mutate(
    child = case_when(
      AGEP < 18 ~ 1,
      AGEP >= 18 ~ 0,
      .default = 0
    )
  ) |> 
  group_by(
    SERIALNO
  ) |> 
  mutate(
    child_count = sum(child),
  ) |> 
  ungroup() |> 
  mutate(
    FAMILY_flag = case_when(
      child_count > 0 ~ "1",
      child_count == 0 ~ "0",
      .default = "0"
    ),
     #Create a "Studio/Non-Defined Bedroom" variable to denote where households do
    #not have a bedroom number.
    studio_flag = case_when(
      BDSP == 0 ~ "Studio/No Defined Bedroom",
      BDSP != 0 ~ "Defined Bedroom",
      .default = "Unknown"
    ),
    #Redefine BDSP to label studios/non-defined bedroom units as One-Bedrooms
    #For purpose of calculating the number of people per bedrooms.
    BDSP = if_else(BDSP == 0, 1, BDSP),
    #Calculate the number of people per bedroom in a housing unit.
    PPB = NP/BDSP,
    #Categorize each housing unit as overcrowded or not based on PPB.
    overcrowded.ppb = case_when(
      PPB > 2.0 ~ "1",
      PPB <= 2.0 ~ "0"
    ),
    #Convert SFN into a numeric column. Introduces NAs for people not in subfamilies
    SFN = as.numeric(SFN),
    #Replace the NA for non-subfamily members with 0.
    SFN = replace_na(SFN, 0)
  ) |>
  group_by(SERIALNO) |> 
  mutate(
    #Create a column which denotes the presence of subfamilies for a household.
    SFN.num = max(SFN)
  ) |> 
  ungroup() |> 
  mutate(
    SFN.flag = if_else(SFN.num > 0, 1, 0)
  )
```

# 1.0 PUMS Analysis

# 1.1.1 Total Households by RPA

```{r}
#Calculate the total number of households across the state
tot.hh <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  summarise(
    hh = sum(WGTP)
  )

#Calculate the total number of households in each RPA
tot.hh.rpa <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    rpa_acr
  ) |> 
  summarise(
    hh = sum(WGTP)
  ) |> 
  ungroup()

#Calculate total family households
tot.hh.family <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    FAMILY_flag
  ) |> 
  summarise(
    hh = sum(WGTP)
  ) |> 
  ungroup()
  
```

# 1.2.1 Overcrowding (PPB) at the State-level

```{r}
#Overcrowding at the State-level
OC.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  bind_cols(tot.hh) |>  
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

#Write the output to csv
write.csv(
  OC.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.PPB.StateLevel.csv"),
  row.names = FALSE
)

#Overcrowding by Family Status at the State-Level
OC.FAMILY.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    FAMILY_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  left_join(
    tot.hh.family,
    by = c("FAMILY_flag")
  ) |> 
  mutate(
    pct = oc.hh/hh
  )

#Write the output to csv
write.csv(
  OC.FAMILY.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.FAMILY.PPB.StateLevel.csv"),
  row.names = FALSE
)

#Overcrowding by Number of Bedrooms
OC.BDRMS.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    BDSP,
    studio_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    BDSP,
    studio_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  )
```

# 1.2.2 Overcrowding (PPB) at the RPA-level

```{r}
#Overcrowding by RPA
OC.RPA.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(households)
  ) |> 
  ungroup() |> 
  left_join(
    tot.hh.rpa,
    by = c("rpa_acr")
  ) |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

#Write output to csv
write.csv(
  OC.RPA.PPB,
  paste0(output_path,"04_Overcrowding/overcrowding.PPB.RPALevel.csv"),
  row.names = FALSE
)

#Overcrowding by RPA and family households
OC.FAMILY.RPA.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    rpa_acr,
    FAMILY_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    FAMILY_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  )

#Write output to csv
write.csv(
  OC.FAMILY.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.FAMILY.PPB.RPALevel.csv"),
  row.names = FALSE
)

#Overcrowding by Number of Bedrooms and RPA
OC.BDRMS.RPA.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |> 
  group_by(
    rpa_acr,
    BDSP,
    studio_flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |> 
  group_by(
    rpa_acr,
    BDSP,
    studio_flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  mutate(
    pct = oc.hh/hh
  )

```

# 2.0 Subfamilies Analysis

# 2.1 Creating a household indicator for presense of subfamily

```{r}
pums <- pums
```

# 2.2 Looking at Composition of Subfamilies to determine if they make sense

```{r}
```

# 2.3 Overcrowded Households by Presense of Subfamilies

```{r}
#Overcrowding by Presence of a Subfamily
OC.SF.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    SFN.flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    SFN.flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

write.csv(
  OC.SF.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.SF.PPB.csv"),
  row.names = FALSE
)

#Overcrowding by Number of Subfamilies
OC.NumSF.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    SFN.num,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    SFN.num
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

write.csv(
  OC.NumSF.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.NumSF.PPB.csv"),
  row.names = FALSE
)

#Overcrowding by RPA and Presence of a Subfamily
OC.SF.RPA.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    SFN.flag,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    SFN.flag
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

write.csv(
  OC.SF.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.SF.PPB.RPAlevel.csv"),
  row.names = FALSE
)

#Overcrowding by RPA and Number of Subfamilies
OC.NumSF.RPA.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    SFN.num,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    SFN.num
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

write.csv(
  OC.NumSF.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.NumSF.PPB.RPAlevel.csv"),
  row.names = FALSE
)

#Analysis:

```

# 3.0 Multigenerational Household Analysis

# 3.1 Redefining Multigenerational households

```{r}
pums <- pums |> 
  mutate(
    #Create a variable that categorizes people into "generations" by their relationship
    #to the householder
    GEN = case_when(
      #
      
    )
  )
```

# 3.2 Overcrowding by Presence of Multiple Generations in a Household

```{r}
#U.S. Census defines "multigenerational" households as those with three or more generations
#present in the household.

#A second definition is more expansive, one which IPUMS has coded into their 
#microdata sample. They record the number of generations present among people in the household
#relative to the householder. A household where the parents of the householder live 
#with them would be a two generation household. One where the grandparents, children, and 
#grandchildren are present would be a four generation household.

#Overcrowding by Multigenerational Households (Census Definition)
OC.MULTG.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    MULTG,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    MULTG
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )

write.csv(
  OC.MULTG.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.PPB.csv"),
  row.names = FALSE
)

#Overcrowding by RPA and Multigenerational Households (Census Definitions)
OC.MULTG.RPA.PPB <- pums |> 
  filter(TYPEHUGQ == 1 & SPORDER == 1) |>  
  group_by(
    rpa_acr,
    MULTG,
    overcrowded.ppb
  ) |> 
  summarise(
    oc.hh = sum(WGTP)
  ) |> 
  ungroup() |>
  group_by(
    rpa_acr,
    MULTG
  ) |> 
  mutate(
    hh = sum(oc.hh)
  ) |> 
  ungroup() |> 
  rowwise() |> 
  mutate(
    pct = oc.hh/hh
  ) |> 
  select(
    -c(hh)
  )
write.csv(
  OC.MULTG.RPA.PPB,
  paste0(output_path, "04_Overcrowding/overcrowding.MULTG.PPB.RPAlevel.csv"),
  row.names = FALSE
)

# Analysis:
```
