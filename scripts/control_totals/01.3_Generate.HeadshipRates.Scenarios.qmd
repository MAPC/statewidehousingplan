---
title: "01.1_HeadshipRate.Scenario.Development"
format: html
editor: visual
---

# 0.0 Setup - Define helper functions, set knitr path, load necessary packages, set muni data keys

# 0.1 - Set knitr path + root for inputs

```{r}
#Use when Rproject is open
#root <- '../../../../Data/Working/Regional_Control_Totals/'

# Base root. Toggle between S: and K: drive depending on mapped paths on your computer
base <- "K:/DataServices/Projects/Current_Projects/"
# base <- "S:/Network Shares/K Drive/DataServices/Projects/Current_Projects/"

#General K drive filepath
root <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/Regional_Control_Totals/")

# Reweighter files path
rwt_path <- paste0(base, "Housing/StatewideHousingPlan/04_Analysis/Data/Working/Reweighter/")

#PUMS K drive filepath
pums_path <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/ipums_2021/")

#Set output filepath
output_path <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/outputs/")

#Set knitr path
knitr::opts_knit$set(root.dir = pums_path)

# Set Scenario
scen <- "Scenario_2"
```

# 0.2 - Set package dependencies, set environment, set up data keys

```{r}
library(tidycensus)
library(tidyverse)
library(data.table)
library(mapcdatakeys)
library(janitor)
library(readxl)
library(here)
library(RPostgreSQL)

# Remove scientific notation
options(scipen = 999)
# Set random seed
set.seed(351)

# Load Libraries for PUMS Analysis and PUMS API query functions
# Sets seed and removes scientific notation
source(here("PUMS_Analysis/PUMS_Helper_Functions.R"))
# source(file = "C:/Project_Work/Local_Data/General/census.data_connection.R")
#source(file = "C:/Project_Work/housing/dbConnections.R")

# Load PUMA x RPA Crosswalk
xw <- read.csv(paste0(rwt_path, "PUMS_data/PUMA10_RPA_crosswalk.csv")) |> 
  mutate(PUMA = str_pad(PUMA, 5, "left", pad = 0))

# # Pull AMI Table for 2021
# ami_table <- get_mapc_database(
#   db.table_name = "hous_section8_income_limits_by_year_m",
#   year = 2021,
#   vars = "*"
# )

```

# 1.0 - Load and process PUMS Data

NOTE: We use the CPI deflator time series to adjust PUMS income to 2013 dollars (for UrbanSim). ACS uses the Consumer Price Index for All Urban Consumers Retroactive Series (R-CPI-U-RS, details here: <https://www.bls.gov/cpi/research-series/r-cpi-u-rs-home.htm>) as opposed to the ASEC/Census which uses C-CPI-U (details here: [*https://www.census.gov/topics/income-poverty/income/guidance/current-vs-constant-dollars.html*](https://www.census.gov/topics/income-poverty/income/guidance/current-vs-constant-dollars.html){.uri}*)*

```{r}
# Set PUMS vintage final year for {tidycensus} API query.
vintage <- 2021

# List of PUMS variables
variable_list <- c('RT', 'PUMA', 'ADJHSG','ADJINC','NP','TYPEHUGQ','BDSP','RMSP','CPLT','HHLDRAGEP',
                   'HHLDRRAC1P','HHLDRHISP', 'HHT', 'HHT2', 'HINCP', 'HUGCL', 'HUPAC', 'HUPAOC',
                   'HUPARC', 'LNGI', 'MULTG', 'NPF', 'NPP', 'NR','NRC', 'PARTNER', 'PSF','R18',
                   'AGEP','RELSHIPP','RAC1P','OC','SFN','SFR','TEN', "SEX", "PINCP", "ESR",
                   'GRPIP', 'OCPIP', 'MV', 'SCHL', 'HISP', 'WKHP')

# SEMP bottom coding has changed from $1 to $4 like WAGP

# Query {tidycensus} for 2017-2021 5-Year PUMS data
pums_data <- pums_query(var.list = variable_list, yr = vintage, srvy = "acs5") |>
  # General Data Cleaning
  mutate(
    # Generate five-year age groupings to match UMDI population projections data.
    ageCAT6 = cut(AGEP, breaks = c(-Inf, seq(4, 84, 5), Inf), labels = 1:18),
    # Renaming the 5-year age group variable.
    AgeCat = ageCAT6,
    # Generate ten-year age groupings 
    # ageCAT4 is the 2020 decennial census age breaks for age of householder - used for 2020 base year control total reweighter targets
    ageCAT4 = case_when(
      AGEP %in% 0:14 ~ 0,
      AGEP %in% 15:24 ~ 1,
      AGEP %in% 25:34 ~ 2,
      AGEP %in% 35:44 ~ 3,
      AGEP %in% 45:54 ~ 4,
      AGEP %in% 55:59 ~ 5,
      AGEP %in% 60:64 ~ 6,
      AGEP %in% 65:74 ~ 7,
      AGEP %in% 75:84 ~ 8,
      AGEP >= 85 ~ 9,
      .default = 0
    ), 
    # Creates a tenure grouping for reweighter file:
    tenure = case_when(# Owned with a mortgage or free and clear -> "1"
      TEN %in% c('1', '2') ~ 1,
      # Rented or occupied without payment of rent -> "2"
      TEN %in% c('3', '4') ~ 2,
      .default = NA
    ), 
    # Creates a tenure grouping for:
    TEN_Group = case_when(# Owned with a mortgage or free and clear -> "Own"
      TEN %in% c('1', '2') ~ "Own",
      # Rented or occupied without payment of rent -> "Rent"
      TEN %in% c('3', '4') ~ "Rent",
      .default = "Unknown"
    ), 
    # Counts as Worker
    # NOTE - Categories are:
    # (0) under 16 or not in labor force
    # (1) in labor force or non-civilian worker
    worker = case_when(
      (ESR == "b" | ESR == 6) ~ 0,
      (ESR == 1 | ESR == 2 | ESR == 3 | ESR == 4 | ESR == 5) ~ 1,
      is.na(ESR) ~ 0
    ),
    # Categorizing Civilian Labor Force or not
    # NOTE: Categories ar
    # (0) under 16 or non-civilian
    # (1) in labor force
    # (2) not in labor force
    lf = case_when(
      ESR == "b" | ESR == 4 | ESR == 5  ~ 0,
      ESR == 1 | ESR == 2 | ESR == 3  ~ 1,
      ESR == 6 ~ 2,
      is.na(ESR) ~ 0
    ),
    # Counts as person
    person = case_when(
      SPORDER != 0 ~ 1,
      SPORDER == 0 ~ 0
    ),
    # Create a household flag for whether there is a child in a household.
    child = case_when(
      AGEP < 18 ~ 1,
      AGEP >= 18 ~ 0,
      .default = 0
    ),
    # Householder Race Groupings.
    RACE_Group = case_when(
      RAC1P == "1" ~ "White Alone",
      RAC1P == "2" ~ "Black or African American Alone",
      RAC1P %in% c("3", "4", "5") ~ "AIAN Alone",
      RAC1P == "6" ~ "Asian Alone",
      RAC1P == "7" ~ "NHPI Alone",
      RAC1P == "8" ~ "Some Other Race Alone",
      RAC1P == "9" ~ "Two or More Races Alone",
      .default = "Unknown"
    ),
    # Householder Hispanic/Non-Hispanic Groupings
    HISP_Group = case_when(
      HISP == "01" ~ "Non-Hispanic",
      HISP != "01" ~ "Hispanic",
      .default = "Unknown"
    ),
    # Educational Attainment Groupings
    # NOTE - Categories are:
    # (1) High school degree or less
    # (2) Associate's degree or some college
    # (3) Bachelor's
    # (4) MA or higher
    SCHL = as.numeric(SCHL),
    eduattn = case_when(
      SCHL <= 17 ~ 1,
      SCHL %in% 18:20 ~ 2,
      SCHL == 21 ~ 3,
      SCHL >= 22 ~ 4,
      is.na(SCHL) ~ 0,
      .default = 0
    ),
    # Create a grouping variable for types of relationships to the householder.
    RELSHIPP_TYPE = case_when(
      # 1 indicates a person in a household that is related in some way to the householder.
      RELSHIPP %in% c(21,22,23,24,25,26,27,28,29,30,31,32,33) ~ 0,
      # 2 indicates a person in a household unrelated to the householder.
      RELSHIPP %in% c(34,35,36) ~ 1,
      # Set a default flag for householders.
      .default = 0
    ),
    # Create a "Studio/Non-Defined Bedroom" variable to denote where households do
    # not have a bedroom number.
    studio_flag = case_when(
      BDSP == 0 ~ "Studio/No Defined Bedroom",
      BDSP != 0 ~ "Defined Bedroom",
      .default = "Unknown"
    ),
    # Redefine BDSP to label studios/non-defined bedroom units as One-Bedrooms
    # For purpose of calculating the number of people per bedrooms.
    BDSP = if_else(BDSP == 0, 1, BDSP),
    # Calculate the number of people per bedroom in a housing unit.
    PPB = NP/BDSP,
    # Categorize each housing unit as overcrowded or not based on PPB.
    overcrowded.ppb = case_when(
      PPB > 2.0 ~ "1",
      PPB <= 2.0 ~ "0"
    ),
    # Convert SFN into a numeric column. Introduces NAs for people not in subfamilies
    SFN = as.numeric(SFN),
    # Replace the NA for non-subfamily members with 0.
    SFN = replace_na(SFN, 0)
  ) |>
  # Creating household flags for person variables.
  group_by(SERIALNO) |> 
  mutate(
    # Create a variable which denotes the presence of subfamilies for a household.
    SFN.num = sum(SFN),
    # Create a variable which denotes the total number of subfamilies in a household.
    SFN.max = max(SFN),
    # Sum the total number of workers in the household
    Worker_Total = sum(worker),
    # Sum the total number of children in the household
    Child_Total = sum(child)
  ) |> 
  ungroup() |> 
  mutate(
  # Create a variable that is a household flag for whether or not a household has children. 
   child_flag = case_when(
      Child_Total > 0 ~ "1",
      Child_Total == 0 ~ "0",
      .default = "0"
    ),
   # Create a household flag for whether or not the household contains a subfamily.
   SFN.flag = if_else(SFN.num > 0, 1, 0),
   # Categorizing worker categories:
   # (0) no workers
   # (1) one worker
   # (2) two workers
   # (3) three or more workers
   WRKHH = case_when(
     Worker_Total == 0 ~ 0,
     Worker_Total == 1 ~ 1,
     Worker_Total == 2 ~ 2,
     Worker_Total >= 3 ~ 3
    ),
  # Determine if person is not hhder vs hhder of:
  # (0) No Workers
  # (1) One Worker 
  # (2) Two Workers
  # (3) Three or more workers
   HHder = case_when(
     SPORDER == 1 & WRKHH == 0 ~ 0,
     SPORDER == 1 & WRKHH == 1 ~ 1,
     SPORDER == 1 & WRKHH == 2 ~ 2,
     SPORDER == 1 & WRKHH == 3 ~ 3,
     SPORDER > 1 ~ 99
   ),
   # Determine what type of household the person is heading or not heading:
   # (1) Householder of Household with Children
   # (2) Non-Householder in a Household with Children
   # (3) Householder of a Household with Multiple Adults and no children
   # (4) Non-Householder in a Household with no children
   # (5) Householder of a Single Person Household
   HHtype = case_when(
     Child_Total >= 1 & NP > 1 & HHder != 99 ~ 1,
     Child_Total >= 1 & NP > 1 & HHder == 99 ~ 2,
     Child_Total == 0 & NP > 1 & HHder != 99 ~ 3,
     Child_Total == 0 & NP > 1 & HHder == 99 ~ 4,
     NP == 1 & HHder != 99 ~ 5
   )
  ) |> 
  mutate(
    # Non-multigenerational household WITH at least one (1) subfamily WITH at least one (1) child
    subset.flag.1 = case_when(
      MULTG == 1 & SFN.flag > 0 & child_flag > 0 ~ 1,
      .default = 0
    ),
    # Multigenerational households WITH at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.2 = case_when(
      MULTG == 2 & SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    ),
    # Households with at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.3 = case_when(
      SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    )
  )

```

# 2.0 Check Size of Subsets Being Used to Create New Households and Generate Estimates of the Number of New Households Created by Splitting Households.

```{r}
#===============================================================================
# -.1 Calculate the number of non-multigenerational households with children with at least one subfamily. Estimate the number of new households created by splitting subfamilies into independent household units. A household with one subfamily will become two households. A household with two subfamilies will become three households. And so on and so forth.
subset.1 <- pums_data |> 
  # Filter for a single household row and non-GQ households.
  filter(SPORDER == 1 & TYPEHUGQ == 1) |> 
  group_by(
    subset.flag.1,
    SFN.max
  ) |> 
  # Summarize the number of households.
  summarise(
   hhds = sum(WGTP)   
  ) |> 
  ungroup() |>
  # Filter for the first subset of households described above.
  filter(subset.flag.1 == 1) |> 
  mutate(
    new.hhds = case_when(
      SFN.max == 1 ~ hhds*2,
      SFN.max == 2 ~ hhds*3,
      SFN.max == 3 ~ hhds*4,
      SFN.max == 4 ~ hhds*5,
      .default = hhds
    ),
    new.hhds = new.hhds - hhds
  )

# Printing the sum of new households slated to be created by splitting up households in subset one.
print(paste0("Splitting non-multigenerational households with children, with at least one subfamily will create ", sum(subset.1$new.hhds), " new households."))

#===============================================================================
# -.2 Calculate the number of multigenerational households with children with at least one subfamily which are overcrowded (> 2.0 persons per bedroom). Estimate the number of new households created by splitting subfamilies into independent household units. A household with one subfamily will become two households. A household with two subfamilies will become three households. And so on and so forth.
subset.2 <- pums_data |> 
  # Filter for a single household row and non-GQ households.
  filter(SPORDER == 1 & TYPEHUGQ == 1) |> 
  group_by(
    subset.flag.2,
    SFN.max
  ) |> 
  # Summarize the number of households.
  summarise(
   hhds = sum(WGTP)   
  ) |> 
  ungroup() |> 
  # Filter for the second subset of households, described above.
  filter(subset.flag.2 == 1) |> 
  mutate(
    new.hhds = case_when(
      SFN.max == 1 ~ hhds*2,
      SFN.max == 2 ~ hhds*3,
      SFN.max == 3 ~ hhds*4,
      SFN.max == 4 ~ hhds*5,
      .default = hhds
    ),
    new.hhds = new.hhds - hhds
  )

# Printing the sum of new households slated to be created by splitting up households in subset two.
print(paste0("Splitting multigenerational households with children, with at least one subfamily, and which are overcrowded will create ", sum(subset.2$new.hhds), " new households."))

# Printing the sum of new households slated to be created by splitting up households in subset one and subset two.
print(paste0("The housheold splitting process will generate ", sum(subset.1$new.hhds) + sum(subset.2$new.hhds), " new households overall."))
```

# 3.0 Seperate Households - Redefine SERIALNO to separate subfamilies into separate households

```{r}
# Create a new SERIALNO variable that represents subfamilies and original households as distinct households.
pums_data.distinct <- pums_data |> 
  mutate(
    SERIALNO.adj = case_when(
      # First Subset
      SFN == 0 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.og"),
      SFN == 1 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf1.adj"),
      SFN == 2 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf2.adj"),
      SFN == 3 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf3.adj"),
      SFN >= 4 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf4.adj"),
      # Second Subset
      SFN == 0 & subset.flag.2 == 1 ~ paste0(SERIALNO, ".2.og"),
      SFN == 1 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf1.adj"),
      SFN == 2 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf2.adj"),
      SFN == 3 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf3.adj"),
      SFN >= 4 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf4.adj"),
      # Default to original SERIALNO for all other households.
      .default = SERIALNO
    ),
    og.flag = case_when(
      # Flag for original household of of subsetted groups
      # First Subset
      SFN == 0 & subset.flag.1 == 1 ~ "1",
      # Second Subset
      SFN == 0 & subset.flag.2 == 1 ~ "2",
      .default = "0"
    ),
    adj.flag = case_when(
      # Flag for the adjusted household of the subsetted groups
      # First Subset
      SFN > 0 & subset.flag.1 == 1 ~ "1",
      #Second Subset
      SFN > 0 & subset.flag.2 == 1 ~ "2",
      .default = "0"
    ),
    adj.flag.2 = case_when(
      # Flag for the adjusted household of the subsetted groups
      # First Subset
      SFN > 0 & subset.flag.1 == 1 ~ "1",
      #Second Subset
      SFN > 0 & subset.flag.2 == 1 ~ "1",
      .default = "0"
    )
  )

```

# 3.1 Reorder Persons in Households to be Split

```{r}
# Reordering persons in the households to be split.
# Subset of households that will not be split that do not need to be reordered
pums_data.og <- pums_data.distinct |> 
  filter(adj.flag.2 == "0")

# Subset of households that WILL be split and need to be reordered within their new household.
pums_data.adj <- pums_data.distinct |> 
  filter(adj.flag.2 == "1") |> 
  group_by(SERIALNO.adj) |> 
  dplyr::arrange(desc(AGEP), .by_group = TRUE) |> 
  ungroup()

# To redefine the person order within a household, we need to make sure the people in the households to be split are at least sort of logically ordered. I am assuming that the oldest person (as captured by AGEP) is the "head" (SPORDER == 1) of the household. We do not want children to head a household in which they have a parent, which they should because that is the definition of a subfamily when they have children.

# Rebinding the pums data subsets with the people in the households to be split properly arranged by age.
full.pums_data.adj <- rbind(pums_data.og, pums_data.adj)

# Removing the interim subsets I no longer need.
# rm(pums_data.adj.og, pums_data.adj.adj)
```

# 3.2 Redefine SPORDER and Relationship Variables

```{r}
# Redefine SPORDER and Relationship Variables in the pums_data.adj dataframe
full.pums_data.adj <- full.pums_data.adj |>
  mutate(
    # Create a row ID number to loop through later.
    ID = row_number()
  ) |> 
  group_by(SERIALNO.adj) |> 
  mutate(
    # Create a new SPORDER variable based on the order of people in the new households (if they are split into new households).
    SPORDER.adj = rank(ID, na.last = TRUE, ties.method = "first")
  ) |> 
  ungroup() |> 
  mutate(
    # Adjusting the RELSHIPP variable to reflect the new SPORDER for split households.
    RELSHIPP.adj = case_when(
      SPORDER.adj == 1 ~ "20",
      SPORDER.adj != 1 & adj.flag == "0" ~ RELSHIPP,
      SPORDER.adj != 1 & adj.flag %in% c("1","2") & SFR %in% c("1","2","3") ~ "21.22.23.24",
      SPORDER.adj != 1 & adj.flag %in% c("1","2") & SFR %in% c("4","5","6") ~ "25.26.27.35",
      .default = "Something's Wrong!"
    ),
    # Adjusting the Subfamily Number variable to reflect having split subfamilies out from their original household.
    SFN.adj = case_when(
      adj.flag %in% c("1","2") ~ 0,
      .default = SFN
    ),
    # Adjusting the Subfamily Relationship variable to reflect having split subfamilies out from their original household.
    SFR.adj = case_when(
      adj.flag %in% c("1","2") ~ "b",
      .default = SFR
    )
  )

# List of assumptions:
# 1. Cant determine the kind of spouse or child non-reference persons are in the new, split households. Could distinguish same or opposite sex spousal relationship with "SEX" variable added to the PUMS data.
# 2. Can we use RELSHIPP to help us be more correct? What about for people who are non-relatives?

```

# 3.3 Re-create households variables for split households

```{r}
# Re-create households variables for split households
full.pums_data.adj <- full.pums_data.adj |> 
  mutate(
    # Counts as Worker
    # NOTE: Categories are:
    # (0) under 16 or not in labor force
    # (1) in labor force or non-civilian worker
    worker = case_when(
      (ESR == "b" | ESR == 6) ~ 0,
      (ESR == 1 | ESR == 2 | ESR == 3 | ESR == 4 | ESR == 5) ~ 1,
      is.na(ESR) ~ 0
    ),
    # Determine if case counts as person
    person = case_when(
      SPORDER != 0 ~ 1,
      SPORDER == 0 ~ 0
    ),
    # Determine if case counts as child
    child = case_when(
      AGEP < 18 ~ 1,
      AGEP >= 18 ~ 0
    )
  ) |> 
  group_by(SERIALNO.adj) |> 
  mutate(
    # Re generate the NP (number of persons in a household) variable
    NP.adj = n(),
    # Re generate the HINCP (household income) variable
    HINCP.adj = sum(PINCP),
    # Adjust income data to 2021 dollars
    HINCP.adj.2021USD = as.numeric(HINCP.adj)*as.numeric(ADJINC),
    # Sum the total number of workers in the household
    Worker_Total = sum(worker),
    # Sum the total number of children in the household
    Child_Total = sum(child)
  ) |> 
  ungroup() |> 
  mutate(
    # Create Income Groups that reflect UrbanSim Household Income Buckets
    # (1) <= $35,000
    # (2) $35,001 - $75,000
    # (3) $75,001 - $125,000
    # (4) $125,001 - $225,000
    # (5) > $225,000
    WAGPALLC_US.adj = 
      cut(
        HINCP.adj.2021USD,
        breaks = c(-Inf, 35000, 75000, 125000, 225000, Inf),
        labels = c("1", "2", "3", "4", "5")
    ),
    # Categorizing Household Size
    size = case_when(
      NP.adj == 1 ~ 1,
      NP.adj == 2 ~ 2,
      NP.adj == 3 ~ 3,
      NP.adj == 4 ~ 4,
      NP.adj == 5 ~ 5,
      NP.adj == 6 ~ 6,
      NP.adj >= 7 ~ 7,
    ),
    # Categorizing worker categories:
    # (0) no workers
    # (1) one worker
    # (2) two workers
    # (3) three or more workers
    WRKHH = case_when(
      Worker_Total == 0 ~ 0,
      Worker_Total == 1 ~ 1,
      Worker_Total == 2 ~ 2,
      Worker_Total >= 3 ~ 3
      ),
    # Determine if person is not hhder vs hhder of 
    # (0) No workers
    # (1) One worker
    # (2) Two workers
    # (3) Three or more workers
    HHder = case_when(
      SPORDER.adj == 1 & WRKHH == 0 ~ 0,
      SPORDER.adj == 1 & WRKHH == 1 ~ 1,
      SPORDER.adj == 1 & WRKHH == 2 ~ 2,
      SPORDER.adj == 1 & WRKHH == 3 ~ 3,
      SPORDER.adj > 1 ~ 99
    ),
    # Determine what type of household the person is heading or not heading 
    # (1) Householder of Household with Children
    # (2) Non-Householder in a Household with Children
    # (3) Householder of a Household with Multiple Adults and no children
    # (4) Non-Householder in a Household with no children 
    # (5) Householder of a Single Person Household
    HHtype = case_when(
      Child_Total >= 1 & NP.adj > 1 & HHder != 99 ~ 1,
      Child_Total >= 1 & NP.adj > 1 & HHder == 99 ~ 2,
      Child_Total == 0 & NP.adj > 1 & HHder != 99 ~ 3,
      Child_Total == 0 & NP.adj > 1 & HHder == 99 ~ 4,
      NP.adj == 1 & HHder != 99 ~ 5
    )
  )

# List of meaningful recalculations:
# 1. NP - summing the number of persons present in original and split subfamily households
# 2. HINCP - summing the individual incomes of household members to generate a new household income.
# 3. HHDERAGEP - Redefine as for split subfamily households.
# 4. PPB - recalculate the overcrowding indicator based on the new number of people in the household. CAVEAT - we're not updating the housing unit characteristics to reflect a change in unit type. We assume the split subfamilies will not intentionally become overcrowded and, therefore, a smaller numerator with constant denominator calculation will reflect, essentially, their reality. 
# 5. Calculations of number of children in a household - sum the number of children in each housing unit to reflect the new compositions of households.
# 6. Calculation of household type - redefine the household type of original and split subfamily households to reflect their new composition. This could mean a household with children will become a household without children (with 2+ adults) and a household with children (and vice versa, depending on the composition of the split subfamily).
# zzz. MULTG - splitting 

# List of assumptions:
# 1. Tenure remains the same. A split subfamily lived in a house owned by the householder, we assume they've also purchased a home. If they were in a rental household, they rent.
# 2. Number of rooms in the house remain the same, even if the number of rooms and bedrooms doesn't necessarily make sense for the split subfamily household. Easier to not make assumptions about the types of housing they rent or buy after splitting out.
# 3. Household income is the sum of incomes of the individuals within the household. Incomes are recalculated for the original household and the new split subfamily household.
# 4. 
```

# 3.4 QA/QC - Check Split Households are Equal to The Number of Households We Expect to Be Split

```{r}
#===============================================================================
# Analyze Subset #1
# Filter for the subset of non-subfamily members from the split household (the "original" household).
subset.1.og.test <- full.pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.1 == 1 & adj.flag == 0)

# Filter for the subset of subfamily members from the split household (the "original" household).
subset.1.adj.test <- full.pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.1 == 1 & adj.flag == 1)

# Print the number of household created by the household split code for Subset #1.
print(sum(subset.1.adj.test$WGTP))

#===============================================================================
# Analyze Subset #2
# Filter for the subset of non-subfamily members from the split household (the "original" household).
subset.2.og.test <- full.pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.2 == 1 & adj.flag == 0)

# Filter for the subset of subfamily members from the split household (the "original" household).
subset.2.adj.test <- full.pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.2 == 1 & adj.flag == 2)

# Print the number of households created by the household split code for Subset #2.
print(sum(subset.2.adj.test$WGTP))

# Print the sum of households created by the household split code for both subsets #1 and #2.
print(sum(sum(subset.1.adj.test$WGTP), sum(subset.2.adj.test$WGTP)))

# Compare the total number of households in subsets #1 and #2 to the number of households created by the household split. If they are not equivalent, a warning message will be printed. If they are, an affirmative will be printed.
if(sum(sum(subset.1$new.hhds), sum(subset.2$new.hhds)) != sum(sum(subset.1.adj.test$WGTP), sum(subset.2.adj.test$WGTP))){
  print("STOP! The number of households identified in the earlier code should match what is produced after splitting households!")
  
} else{
  # Write a file with Households for Subset 1
  write.csv(
    subset.1.adj.test,
    file = paste0(rwt_path, '/PUMS_data/PUMS2021.Split_subset1.csv'),
    row.names = FALSE
  )
  
  # Write a file with Households for Subset 2
  write.csv(
    subset.2.adj.test,
    file = paste0(rwt_path, '/PUMS_data/PUMS2021.Split_subset2.csv'),
    row.names = FALSE
  )
  
  print("Proceed!")
}

```

# 3.5 Create PUMS Extract for Reweighter

```{r}
# Create a check to see if the file has already been written.
file_check = paste0(rwt_path, '/PUMS_data/PUMS2021.Split_formatted.csv')

if (!file.exists(file_check)){
  
  # Creating the PUMS data extract for Scenario 2
  pums_data.adj.rwt <- full.pums_data.adj |>
    left_join(
      xw,
      by = c("PUMA"),
      relationship = "many-to-many"
    )
  
  # Write PUMS extract to reweighter input folder for Scenario 2
  write.csv(
    pums_data.adj.rwt,
    file = paste0(rwt_path, '/PUMS_data/PUMS2021.Split_formatted.csv'),
    row.names = FALSE
  )
  
} else if (file.exists(file_check)){
  
  print("File already exists!")
  
}

```

# 3.6 Analysis of Subset Households

```{r}
# Full dataframe of subset households.
subset.adj.test <- bind_rows(subset.1.adj.test, subset.2.adj.test)
  
# #Households by RPA
# tbl.1 <- subset.adj.test |> 
#   filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
#   group_by(rpa_acr) |> 
#   summarise(
#     hhds = sum(WGTP)
#   ) |> 
#   ungroup()
# 
# write.csv(tbl.1, file = paste0(root,scen,"/Analysis/tbl.1_hh.by.rpa.csv"), row.names = F)

# Households by Household Type
tbl.2 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    HHtype
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.2, file = paste0(root,scen,"/Analysis/tbl.2_hh.by.HHtype.csv"), row.names = F)

# #Households by Household Types and RPA
# tbl.3 <- subset.adj.test |> 
#   filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
#   group_by(
#     rpa_acr,
#     HHtype
#   ) |> 
#   summarise(
#     hhds = sum(WGTP)
#   ) |> 
#   ungroup()
# 
# write.csv(tbl.3, file = paste0(root,scen,"/Analysis/tbl.3_hh.by.rpa.HHtype.csv"), row.names = F)

#Households by Household Size
tbl.4 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    NP.adj
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.4, file = paste0(root,scen,"/Analysis/tbl.4_hh.by.HHsize.csv"), row.names = F)

#Households by Presence of Children
tbl.5 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    Child_Total
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.5, file = paste0(root,scen,"/Analysis/tbl.5_hh.by.NumChildren.csv"), row.names = F)

#Households by Household Size and Presence of Children
tbl.6 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    NP.adj,
    Child_Total
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.6, file = paste0(root,scen,"/Analysis/tbl.6_hh.by.HHsize.NumChildren.csv"), row.names = F)

#Households by Household Income
tbl.7 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    WAGPALLC_US.adj
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.7, file = paste0(root,scen,"/Analysis/tbl.7_hh.by.HHincome.csv"), row.names = F)

#Households by Householder Age
tbl.8 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    ageCAT6
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.8, file = paste0(root,scen,"/Analysis/tbl.8_hh.by.HHerAge.csv"), row.names = F)

#Households by the Number of Workers in the Household
tbl.9 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    Worker_Total
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.9, file = paste0(root,scen,"/Analysis/tbl.9_hh.by.NumWorker.csv"), row.names = F)

# Households by Subset and Overcrowding
tbl.10 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    overcrowded.ppb,
    adj.flag
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

write.csv(tbl.10, file = paste0(root,scen,"/Analysis/tbl.10_hh.by.OverCrowd.SubsetNum.csv"), row.names = F)

# Persons in households by Race and Ethnicity
tbl.11 <- subset.adj.test |> 
  filter(TYPEHUGQ == 1) |> 
  group_by(
    RACE_Group,
    HISP_Group
  ) |> 
  summarise(
    hhds = sum(PWGTP)
  ) |> 
  ungroup()

write.csv(tbl.11, file = paste0(root,scen,"/Analysis/tbl.11_persons.by.Race.Eth.csv"), row.names = F)

# Persons in households by Educational Attainment
tbl.12 <- subset.adj.test |> 
  filter(TYPEHUGQ == 1) |> 
  group_by(
    eduattn
  ) |> 
  summarise(
    hhds = sum(PWGTP)
  ) |> 
  ungroup()

write.csv(tbl.12, file = paste0(root,scen,"/Analysis/tbl.12_persons.by.eduattainment.csv"), row.names = F)

```

# 4.0 Subset Sampling
# 4.1 Create Subsets of PUMS Records
```{r}
# Subset of unsplit that do not need to be reordered
partial.pums_data.og <- full.pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 0)

# Subset of Subset 1 split households.
partial.pums_data.subset1 <- full.pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.1 == 1 & adj.flag == 1)

# Subset of Subset 2 split households.
partial.pums_data.subset2 <- full.pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.2 == 1 & adj.flag == 2)

#
print(sum(sum(partial.pums_data.subset1$WGTP), sum(partial.pums_data.subset2$WGTP)))
```

# 4.2 Sample PUMS Records from the Subsets for each Year
```{r}
# Create the list of years for which we want to create a sample of subset households.
years <- c(2025,2030,2035,2040,2045,2050)

# Calculate the total number of rows in the two subset datasets.
total_split.hhds <- as.numeric(sum(nrow(partial.pums_data.subset1), nrow(partial.pums_data.subset2)))

# Calculate the sample size of rows we want to pull from the subsets in each year.
sample.size <- round(total_split.hhds*0.25, 0)

for (i in years){
  
  # Print Statement so I know which year we're in.
  print(paste0("Begin sampling for year ", i))
  
  # Set the initial number of rows in each subset.
  # Will be recalculated in each loop.
  df.row.1 <- as.numeric(nrow(partial.pums_data.subset1))
  df.row.2 <- as.numeric(nrow(partial.pums_data.subset2))
  
  # Prints the total remaining rows in the subset dataframes being sampled.
  print(paste0("First Subset has ", df.row.1, " rows remaining."))
  print(paste0("Second Subset has ", df.row.2, " rows remaining."))
  
  if (df.row.1 >= sample.size) {
    
    print("Following Condition 1 Logic.")
    # Sample from the subset pums records.
    tmp <- slice_sample(partial.pums_data.subset1, n = sample.size, replace = F) |> 
      mutate(
        sample = i
      )
    # Print the number of households that have been sampled.
    print(sum(tmp$WGTP))
    # Remove sampled households from the subset.
    partial.pums_data.subset1 <- partial.pums_data.subset1 |> 
      filter(!SERIALNO.adj %in% tmp$SERIALNO.adj)
    
    # Creates a dataframe of the sampled data for loop year.
    assign(paste0("pums.sample_",i), tmp)
    
    # Remove dataframes that need to be recycled in the next loop.
    rm(tmp)
    
  } else if (df.row.1 < sample.size & df.row.1 != 0 & df.row.2 >= sample.size) {
    
    print("Following Condition 2 Logic.")
    # Calculate the sample size for each sample when there are not enough rows to sample without replacement in the first dataframe.
    tmp.sample.size.1 <- df.row.1
    tmp.sample.size.2 <- sample.size - tmp.sample.size.1
    
    # Sample from the subset pums records. 
    tmp.1 <- slice_sample(partial.pums_data.subset1, n = tmp.sample.size.1, replace = F)
    tmp.2 <- slice_sample(partial.pums_data.subset2, n = tmp.sample.size.2, replace = F)
    tmp <- bind_rows(tmp.1, tmp.2) |> 
      mutate(
        sample = i
      )
    
    # Print the number of households that have been sampled.
    print(sum(sum(tmp.1$WGTP), sum(tmp.2$WGTP)))
    
    # Remove sampled households from the subset.
    partial.pums_data.subset1 <- partial.pums_data.subset1 |> 
      filter(!SERIALNO.adj %in% tmp.1$SERIALNO.adj)
    partial.pums_data.subset2 <- partial.pums_data.subset2 |> 
      filter(!SERIALNO.adj %in% tmp.2$SERIALNO.adj)
    
    # Creates a dataframe of the sampled data for loop year.
    assign(paste0("pums.sample_",i), tmp)
    
    # Remove dataframes that need to be recycled in the next loop.
    rm(tmp, tmp.1, tmp.2)
    
  } else if (df.row.1 == 0 & df.row.2 >= sample.size){
    
    print("Following Condition 3 Logic.")
    # Sample from the subset pums records.
    tmp <- slice_sample(partial.pums_data.subset2, n = sample.size, replace = F) |> 
      mutate(
        sample = i
      )
    # Print the number of households that have been sampled.
    print(sum(tmp$WGTP))
    # Remove sampled households from the subset.
    partial.pums_data.subset2 <- partial.pums_data.subset2 |> 
      filter(!SERIALNO.adj %in% tmp$SERIALNO.adj)
    
    # Creates a dataframe of the sampled data for loop year.
    assign(paste0("pums.sample_",i), tmp)
    
    # Remove dataframes that need to be recycled in the next loop.
    rm(tmp)
    
  } else if (df.row.2 < sample.size){
    
    print("Following Condition 4 Logic.")
    # Set a sample size less than the standard sample size
    tmp.2.sample.size <- df.row.2
    # Sample from the subset pums records.
    tmp <- slice_sample(partial.pums_data.subset2, n = tmp.2.sample.size, replace = F) |> 
      mutate(
        sample = i
      )
    # Print the number of households that have been sampled.
    print(sum(tmp$WGTP))
    # Remove sampled households from the subset.
    partial.pums_data.subset2 <- partial.pums_data.subset2 |> 
      filter(!SERIALNO.adj %in% tmp$SERIALNO.adj)
    
    # Creates a dataframe of the sampled data for loop year.
    assign(paste0("pums.sample_",i), tmp)
    
    # Remove dataframes that need to be recycled in the next loop.
    rm(tmp)
    
  }
  
}

# QC Check - Tells us if sampling is complete.
if (sum(df.row.1, df.row.2) == 0){
  print("Finished sampling PUMS subsets.")
} else{
  print("STOP! Data still exist in the subset dataframes. Please review sampling script.")
}

# Put all the samples together for ease in the subsequent sections
pums.sample <- bind_rows(pums.sample_2025, pums.sample_2030, pums.sample_2035,
                         pums.sample_2040, pums.sample_2045, pums.sample_2050)

```

# 5.0 Calculate Headship Rates
# 5.1 Create Headship rate calculation function

```{r}
create_hdsp.r <- function(df){
  # Generating headship rates by RPA and 5-year age group for the ACS 2017-2021 PUMS
  hdsp.r <- df |>
    # Join the PUMA to RPA crosswalk to the PUMS data
    left_join(
      xw,
      by = c('PUMA'),
      relationship = "many-to-many"
    ) |>
    # Includes only observations for people in households (omits GQ)
    filter(TYPEHUGQ == "1") |>
    # Groups by variables in the dataframe necessary to getting the granularity of
    # data we're interested in.
    group_by(rpa_acr, ageCAT6) |>
    # Computes the weighted sum of individuals in each HH type category by the groups
    # assigned above.
    count(var = HHtype, wt = WGTP)  |>
    ungroup() |>
    group_by(rpa_acr, ageCAT6) |>
    # Recodes factor variables as the categories they represent.
    # Converts numbers into frequencies.
    mutate(
      var = case_when(
        var == 1 ~ "hhderchild",
        var == 2 ~ "nothhderchild",
        var == 3 ~ "hhdernochild",
        var == 4 ~ "nothhdernochild",
        var == 5 ~ "single"
      ),
      freq = (n / sum(n))
    ) |>
    # Removes the level of aggregation set earlier by group_by()
    ungroup() |>
    select(-c(n)) |>
    dplyr::rename(freq.split = freq) |>
    mutate(ageCAT6 = as.factor(ageCAT6))
  
  return(hdsp.r)
  
}
```

# 5.2 Calculate Headship Rates for Split Households PUMS

```{r}
# The goal of this script is to remove PUMS records from the standard PUMS data that belong to the subsets of split households generated in earlier code chucks and randomly sampled by each 5-year projections period.

# To simulate households "splitting" in the headship rate calculations, each 5-year periods sees the households sampled earlier break into their component parts while households in subsequent samples remain together. In five year steps, households split cumulatively. For example, in 2030, split households from 2025 and 2030 are present in the PUMS data; in 2035, split households from 2025, 2030, and 2035 are present.

# Headship rates are then calculated using the newly created PUMS datasets for each five year period.
# Headship rates for 2020 will be the standard headship rates created by the 2017-2021 PUMS data.

#===============================================================================

# Assign the full PUMS 2017-2021 5-year ACS Data to a new object
pums <- pums_data

# Loop which reassembles PUMS data for each five year projection period using sampled split household data.

for (i in years) {
  
  if(i == 2020){
    
  } else if(i == 2025){
    
    # Creates a list of SERIALNO to include from the split household data (both the newly create households and the original household which is now smaller).
    sn <- pums.sample |>
      filter(sample == i) |>
      select(SERIALNO) |>
      pull()
    
    # Create a dataframe of original households that had subfamilies split out from it.
    og <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 0) |>
      filter(SERIALNO %in% sn)
    
    # Create a dataframe of split households.
    adj <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 1) |>
      filter(SERIALNO %in% sn)
    
    # Remove unsplit original and split households from standard PUMS dataset by SERIALNO
    tmp_pums <- pums |> filter(!SERIALNO %in% sn)
    
    # Add the original and split households from this year's sample (and cumulative samples) to the standard PUMS dataset.
    # This simulates the formation of new households.
    done_pums <- bind_rows(tmp_pums, og, adj) |> mutate(SERIALNO.adj = coalesce(SERIALNO))
    
    # Calculate headship rates for this projection year.
    hdsp.r <- create_hdsp.r(df = done_pums)|> dplyr::rename(freq.split2025 = freq.split)
    
    # Assign the headship rate object to a year specific object name.
    assign(paste0("hdsp.r_", i), hdsp.r)
    
    # Remove dataframes that will be recreated in the next loop to avoid accidentally using residual data.
    rm(sn, og, tmp_pums, done_pums, hdsp.r)
    
  } else if (i == 2030){
    
    # Creates a list of SERIALNO to include from the split household data (both the newly create households and the original household which is now smaller).
    sn <- pums.sample |>
      filter(sample == i | sample == (i - 5)) |>
      select(SERIALNO) |>
      pull()
    
    # Create a dataframe of original households that had subfamilies split out from it.
    og <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 0) |>
      filter(SERIALNO %in% sn)
    
    # Create a dataframe of split households.
    adj <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 1) |>
      filter(SERIALNO %in% sn)
    
    # Remove unsplit original and split households from standard PUMS dataset by SERIALNO
    tmp_pums <- pums |> filter(!SERIALNO %in% sn)
    
    # Add the original and split households from this year's sample (and cumulative samples) to the standard PUMS dataset.
    # This simulates the formation of new households.
    done_pums <- bind_rows(tmp_pums, og, pums.sample_2025) |> mutate(SERIALNO.adj = coalesce(SERIALNO))
    
    # Calculate headship rates for this projection year.
    hdsp.r <- create_hdsp.r(df = done_pums)|> dplyr::rename(freq.split2030 = freq.split)
    
    # Assign the headship rate object to a year specific object name.
    assign(paste0("hdsp.r_", i), hdsp.r)
    
        # Remove dataframes that will be recreated in the next loop to avoid accidentally using residual data.
    rm(sn, og, tmp_pums, done_pums, hdsp.r)
    
  } else if (i == 2035){
    
    # Creates a list of SERIALNO to include from the split household data (both the newly create households and the original household which is now smaller).
    sn <- pums.sample |>
      filter(sample == i| sample == (i - 5) | sample == (i - 10)) |>
      select(SERIALNO) |>
      pull()
    
    # Create a dataframe of original households that had subfamilies split out from it.
    og <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 0) |>
      filter(SERIALNO %in% sn)
    
    # Create a dataframe of split households.
    adj <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 1) |>
      filter(SERIALNO %in% sn)
    
    # Remove unsplit original and split households from standard PUMS dataset by SERIALNO
    tmp_pums <- pums |> filter(!SERIALNO %in% sn)
    
    # Add the original and split households from this year's sample (and cumulative samples) to the standard PUMS dataset.
    # This simulates the formation of new households.
    done_pums <- bind_rows(tmp_pums, og, pums.sample_2025) |> mutate(SERIALNO.adj = coalesce(SERIALNO))
    
    # Calculate headship rates for this projection year.
    hdsp.r <- create_hdsp.r(df = done_pums)|> dplyr::rename(freq.split2035 = freq.split)
    
    # Assign the headship rate object to a year specific object name.
    assign(paste0("hdsp.r_", i), hdsp.r)
  
    # Remove dataframes that will be recreated in the next loop to avoid accidentally using residual data.
    rm(sn, og, tmp_pums, done_pums, hdsp.r)
    
  } else if (i == 2040){
    
    # Creates a list of SERIALNO to include from the split household data (both the newly create households and the original household which is now smaller).
    sn <- pums.sample |>
      filter(sample == i | sample == (i - 5) | sample == (i - 10) | sample == (i - 15)) |>
      select(SERIALNO) |>
      pull()
    
    # Create a dataframe of original households that had subfamilies split out from it.
    og <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 0) |>
      filter(SERIALNO %in% sn)
    
    # Create a dataframe of split households.
    adj <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 1) |>
      filter(SERIALNO %in% sn)
    
    # Remove unsplit original and split households from standard PUMS dataset by SERIALNO
    tmp_pums <- pums |> filter(!SERIALNO %in% sn)
    
    # Add the original and split households from this year's sample (and cumulative samples) to the standard PUMS dataset.
    # This simulates the formation of new households.
    done_pums <- bind_rows(tmp_pums, og, pums.sample_2025) |> mutate(SERIALNO.adj = coalesce(SERIALNO))
    
    # Calculate headship rates for this projection year.
    hdsp.r <- create_hdsp.r(df = done_pums)|> dplyr::rename(freq.split2040 = freq.split)
    
    # Assign the headship rate object to a year specific object name.
    assign(paste0("hdsp.r_", i), hdsp.r)
    
    # Remove dataframes that will be recreated in the next loop to avoid accidentally using residual data.
    rm(sn, og, tmp_pums, done_pums, hdsp.r)
    
  } else if (i == 2045){
    
    # Creates a list of SERIALNO to include from the split household data (both the newly create households and the original household which is now smaller).
    sn <- pums.sample |>
      filter(sample == i | sample == (i - 5) | sample == (i - 10) | sample == (i - 15) | sample == (i - 20)) |>
      select(SERIALNO) |>
      pull()
    
    # Create a dataframe of original households that had subfamilies split out from it.
    og <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 0) |>
      filter(SERIALNO %in% sn)
    
    # Create a dataframe of split households.
    adj <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 1) |>
      filter(SERIALNO %in% sn)
    
    # Remove unsplit original and split households from standard PUMS dataset by SERIALNO
    tmp_pums <- pums |> filter(!SERIALNO %in% sn)
    
    # Add the original and split households from this year's sample (and cumulative samples) to the standard PUMS dataset.
    # This simulates the formation of new households.
    done_pums <- bind_rows(tmp_pums, og, pums.sample_2025) |> mutate(SERIALNO.adj = coalesce(SERIALNO))
    
    # Calculate headship rates for this projection year.
    hdsp.r <- create_hdsp.r(df = done_pums)|> dplyr::rename(freq.split2045 = freq.split)
    
    # Assign the headship rate object to a year specific object name.
    assign(paste0("hdsp.r_", i), hdsp.r)
    
    # Remove dataframes that will be recreated in the next loop to avoid accidentally using residual data.
    rm(sn, og, tmp_pums, done_pums, hdsp.r)
    
  } else if (i == 2050){
    
    # Creates a list of SERIALNO to include from the split household data (both the newly create households and the original household which is now smaller).
    sn <- pums.sample |>
      filter(sample == i | sample == (i - 5) | sample == (i - 10) | sample == (i - 15) | sample == (i - 20) |sample == (i -25)) |>
      select(SERIALNO) |>
      pull()
    
    # Create a dataframe of original households that had subfamilies split out from it.
    og <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 0) |>
      filter(SERIALNO %in% sn)
    
    # Create a dataframe of split households.
    adj <- full.pums_data.adj |> 
      filter(TYPEHUGQ == 1 & (subset.flag.1 != 0 | subset.flag.2 !=0) & adj.flag == 1) |>
      filter(SERIALNO %in% sn)
    
    # Remove unsplit original and split households from standard PUMS dataset by SERIALNO
    tmp_pums <- pums |> filter(!SERIALNO %in% sn)
    
    # Add the original and split households from this year's sample (and cumulative samples) to the standard PUMS dataset.
    # This simulates the formation of new households.
    done_pums <- bind_rows(tmp_pums, og, pums.sample_2025) |> mutate(SERIALNO.adj = coalesce(SERIALNO))
    
    # Calculate headship rates for this projection year.
    hdsp.r <- create_hdsp.r(df = done_pums) |> dplyr::rename(freq.split2050 = freq.split)
    
    # Assign the headship rate object to a year specific object name.
    assign(paste0("hdsp.r_", i), hdsp.r)
    
    # Remove dataframes that will be recreated in the next loop to avoid accidentally using residual data.
    rm(sn, og, tmp_pums, done_pums, hdsp.r)
    
  }
  
  # Tell us when the loop is finished calculating the headship rates.
  print(paste0("Created Headship Rates for ", i, " !"))
}
```
# 5.3 Merge Headship rate files together and export file
```{r}
# Left join all headship rate dataframes to create single file to export.
hdsp.r_scenario2 <- purrr::reduce(
  list(hdsp.r_2025, hdsp.r_2030, hdsp.r_2035, hdsp.r_2040, hdsp.r_2045, hdsp.r_2050),
  dplyr::left_join,
  by = c('rpa_acr','ageCAT6','var')
)

# Write .csv file
write.csv(
  hdsp.r_scenario2,
  paste0(rwt_path,"Headship_rates/headship.rates.1721_household.split.csv"),
  row.names = FALSE
)
```

```{r}
# Generating headship rates by RPA and 5-year age group for the ACS 2017-2021 PUMS
headship_rates.split <- pums_data.adj |> 
  # Join the PUMA to RPA crosswalk to the PUMS data
  left_join(
    xw,
    by = c('PUMA')
  ) |>
  # Includes only observations for people in households (omits GQ)                       
  filter(SPORDER.adj == "1" & TYPEHUGQ == "1") |> 
  # Groups by variables in the dataframe necessary to getting the granularity of
  # data we're interested in.
  group_by(rpa_acr, ageCAT6) |> 
  # Computes the weighted sum of individuals in each HH type category by the groups
  # assigned above.
  count(var = HHtype, wt = WGTP)  |>
  ungroup() |> 
  group_by(rpa_acr, ageCAT6) |>
  # Recodes factor variables as the categories they represent.
  # Converts numbers into frequencies.                       
  mutate(
    var = case_when(
      var == 1 ~ "hhderchild",
      var == 2 ~ "nothhderchild",
      var == 3 ~ "hhdernochild",
      var == 4 ~ "nothhdernochild",
      var == 5 ~ "single"),
    freq = (n/sum(n))) |> 
  # Removes the level of aggregation set earlier by group_by()
  ungroup() |> 
  select(
    -c(n)
  ) |> 
  dplyr::rename(
    freq.split = freq
  ) |> 
  mutate(
    ageCAT6 = as.factor(ageCAT6)
  )

# # Generating headship rates by RPA and 5-year age group for the ACS 2017-2022 PUMS
# tenure_rates.split <- pums_data.adj |> 
#   # Join the PUMA to RPA crosswalk to the PUMS data
#   left_join(
#     xw,
#     by = c('PUMA')
#   ) |>
#   # Includes only observations for people in households (omits GQ)                       
#   filter(SPORDER.adj == 1 & TYPEHUGQ == "1") |> 
#   # Groups by variables in the dataframe necessary to getting the granularity of
#   # data we're interested in.
#   group_by(rpa_acr, ageCAT6) |> 
#   # Computes the weighted sum of individuals in each HH type category by the groups
#   # assigned above.
#   count(var = TEN_Group, wt = WGTP)  |>
#   ungroup() |> 
#   group_by(rpa_acr, ageCAT6) |>
#   # Converts numbers into frequencies.                       
#   mutate(
#     freq = (n/sum(n))
#   ) |> 
#   # Removes the level of aggregation set earlier by group_by()
#   ungroup() |> 
#   select(
#     -c(n)
#   ) |> 
#   dplyr::rename(
#     freq.split = freq
#   ) |> 
#   mutate(
#     ageCAT6 = as.factor(ageCAT6)
#   )

# QC Check - determine if the frequencies in each RP, Age Group crosstab add to 1
hr_check <- headship_rates.split |> 
  group_by(
    rpa_acr,
    ageCAT6
  ) |> 
  summarise(
    freq_check = sum(freq.split)
  ) |> 
  ungroup() |> 
  mutate(
    flag = ifelse(freq_check != 1, 1, 0)
  )

# # QC Check - determine if the frequencies in each Tenure, Age Group crosstab add to 1
# ten_check <- tenure_rates.split |> 
#   group_by(
#     rpa_acr,
#     ageCAT6
#   ) |> 
#   summarise(
#     freq_check = sum(freq.split)
#   ) |> 
#   ungroup() |> 
#   mutate(
#     flag = ifelse(freq_check != 1, 1, 0)
#   )

# Print statement to verify w/in headhship groups that the numbers all add up accordingly.
if (sum(hr_check$flag) > 0 | sum(ten_check$flag) > 0){
  # Print when numbers are incorrect.
  print("STOP! Check headship rate calculations!")
} else{
  #Print when numbers are correct.
  print("Proceed!")
  
  # Remove QC files.
  rm(hr_check, ten_check)
}

# Export headship rates
write.csv(
  headship_rates.split,
  paste0(rwt_path,"Headship_rates/headship.rates.1721_household.split.csv"),
  row.names = FALSE
)

# # Export tenure rates
# write.csv(
#   tenure_rates.split,
#   paste0(rwt_path,"Headship_rates/tenure.rates.1721_household.split.csv"),
#   row.names = FALSE
# )

```
