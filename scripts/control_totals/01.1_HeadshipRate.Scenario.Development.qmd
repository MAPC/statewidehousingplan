---
title: "01.1_HeadshipRate.Scenario.Development"
format: html
editor: visual
---

# 0.0 Setup - Define helper functions, set knitr path, load necessary packages, set muni data keys

# 0.1 - Set knitr path + root for inputs

```{r}
#Use when Rproject is open
#root <- '../../../../Data/Working/Regional_Control_Totals/'

# Base root. Toggle between S: and K: drive depedning on mapped paths on your computer
base <- "K:/DataServices/Projects/Current_Projects/"
#base <- "S:/Network Shares/K Drive/DataServices/Projects/Current_Projects/"

#General K drive filepath
root <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/Regional_Control_Totals/")

# Reweighter files path
rwt_path <- paste0(base, "Housing/StatewideHousingPlan/04_Analysis/Data/Working/Reweighter/")

#PUMS K drive filepath
pums_path <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/ipums_2021/")

#Set output filepath
output_path <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/outputs/")

#Set knitr path
knitr::opts_knit$set(root.dir = pums_path)
```

# 0.2 - Set package dependencies, set environment, set up data keys

```{r}
library(tidycensus)
library(tidyverse)
library(data.table)
library(reticulate)
library(mapcdatakeys)
library(janitor)
library(readxl)

# Remove scientific notation
options(scipen = 999)
# Set random seed
set.seed(351)

# Load Libraries for PUMS Analysis and PUMS API query functions
# Sets seed and removes scientific notation
source("C:/Project_Work/statewidehousingplan/PUMS_Analysis/PUMS_Helper_Functions.R")

# Load PUMA x RPA Crosswalk
xw <- read.csv(paste0(rwt_path, "PUMS_data/PUMA10_RPA_crosswalk.csv")) |> 
  mutate(PUMA = str_pad(PUMA, 5, "left", pad = 0))

```

# 1.0 - Load and process PUMS Data

NOTE: We use the CPI deflator time series to adjust PUMS income to 2013 dollars (for UrbanSim). ACS uses the Consumer Price Index for All Urban Consumers Retroactive Series (R-CPI-U-RS, details here: <https://www.bls.gov/cpi/research-series/r-cpi-u-rs-home.htm>) as opposed to the ASEC/Census which uses C-CPI-U (details here: [*https://www.census.gov/topics/income-poverty/income/guidance/current-vs-constant-dollars.html*](https://www.census.gov/topics/income-poverty/income/guidance/current-vs-constant-dollars.html){.uri}*)*

```{r}
#Set PUMS vintage final year for {tidycensus} API query.
vintage <- 2021

#List of PUMS variables
variable_list <- c('RT', 'PUMA', 'ADJHSG','ADJINC','NP','TYPEHUGQ','BDSP','RMSP','CPLT','HHLDRAGEP',
                   'HHLDRRAC1P','HHLDRHISP', 'HHT', 'HHT2', 'HINCP', 'HUGCL', 'HUPAC', 'HUPAOC',
                   'HUPARC', 'LNGI', 'MULTG', 'NPF', 'NPP', 'NR','NRC', 'PARTNER', 'PSF','R18',
                   'AGEP','RELSHIPP','RAC1P','OC','SFN','SFR','TEN')

#SEMP bottom coding has changed from $1 to $4 like WAGP

# Load CPI time series for deflating income variable
cpi <- fread(paste0(root,'cpi_deflators_by_year.csv'))

# Creat variable which is CPI index for 2013
cpi.2013 <- cpi |> filter(year == 2013) |> pull(index)

# Create variable which is CPI index for ACS vintage year
cpi.present <- cpi |> filter(year == vintage) |> pull(index)

# Calculate the CPI deflator for ACS Vintage year
cpi.deflator <- cpi.2013 / cpi.present

#Query {tidycensus} for 2017-2021 5-Year PUMS data
pums_data <- pums_query(var.list = variable_list, yr = vintage, srvy = "acs5") |>
  # Join the PUMA to RPA ceosswalk to the PUMS data
  left_join(
    xw,
    by = c('PUMA')
  ) |> 
  # General Data Cleaning
  # Create a household flag for whether there is a child in a household.
  mutate(
    child = case_when(
      AGEP < 18 ~ 1,
      AGEP >= 18 ~ 0,
      .default = 0
    ),
    # Create a grouping variable for types of relationships to the householder.
    RELSHIPP_TYPE = case_when(
      # 1 indicates a person in a household that is related in some way to the householder.
      RELSHIPP %in% c(21,22,23,24,25,26,27,28,29,30,31,32,33) ~ 0,
      # 2 indicates a person in a household unrelated to the householder.
      RELSHIPP %in% c(34,35,36) ~ 1,
      # Set a default flag for householders.
      .default = 0
    ),
    TEN.desc = case_when(
      TEN == "1" ~ "Owned with mortgage or loan",
      TEN == "2" ~ "Owned free and clear",
      TEN == "3" ~ "Rented",
      TEN == "4" ~ "Occupied without payment of rent"
    ),
    # Create a "Studio/Non-Defined Bedroom" variable to denote where households do
    # not have a bedroom number.
    studio_flag = case_when(
      BDSP == 0 ~ "Studio/No Defined Bedroom",
      BDSP != 0 ~ "Defined Bedroom",
      .default = "Unknown"
    ),
    # Redefine BDSP to label studios/non-defined bedroom units as One-Bedrooms
    # For purpose of calculating the number of people per bedrooms.
    BDSP = if_else(BDSP == 0, 1, BDSP),
    # Calculate the number of people per bedroom in a housing unit.
    PPB = NP/BDSP,
    # Categorize each housing unit as overcrowded or not based on PPB.
    overcrowded.ppb = case_when(
      PPB > 2.0 ~ "1",
      PPB <= 2.0 ~ "0"
    ),
    # Convert SFN into a numeric column. Introduces NAs for people not in subfamilies
    SFN = as.numeric(SFN),
    # Replace the NA for non-subfamily members with 0.
    SFN = replace_na(SFN, 0),
    # Adjust Household income (HINCP) to constant dollars (USD2021)
    HINCP_adj = as.numeric(HINCP)*as.numeric(ADJINC),
    # Household Income Groupings consistent with UrbanSim groupings
    HH.Income.Grp = case_when(
      HINCP_adj <= 35000 ~ "<=$35,000",
      HINCP_adj > 35000 & HINCP_adj <= 75000 ~ "$35,001-$75,000",
      HINCP_adj > 75000 & HINCP_adj <= 125000 ~ "$75,001-$125,000",
      HINCP_adj > 125000 & HINCP_adj <= 225000 ~ "$125,001-$225,000",
      HINCP_adj > 225000 ~ ">$225,000",
      .default = "0"
    ),
    # Householder Race Groupings. 
    HHLDER.RACE.Grp = case_when(
      HHLDRRAC1P == "1" ~ "White Alone",
      HHLDRRAC1P == "2" ~ "Black or African American Alone",
      HHLDRRAC1P %in% c("3", "4", "5") ~ "AIAN Alone",
      HHLDRRAC1P == "6" ~ "Asian Alone",
      HHLDRRAC1P == "7" ~ "NHPI Alone",
      HHLDRRAC1P == "8" ~ "SOR Alone",
      HHLDRRAC1P == "9" ~ "Two or More Races Alone",
      .default = "Unknown"
    ),
    # Householder Latinx Groupings
    HHDER.HISP.Grp = case_when(
      HHLDRHISP == "01" ~ "Non-Hispanic",
      HHLDRHISP != "01" ~ "Hispanic",
      .default = "Unknown"
    ),
    # Create a flag for whether a person in a household is a roommate or housemate
    roommate.flag = case_when(
      RELSHIPP == 34 ~ 1,
      RELSHIPP != 34 ~ 0,
      .default = 0
    )
  ) |>
  # Creating household flags for person variables.
  group_by(SERIALNO) |> 
  mutate(
    # Create a variable which is the sum of the number of children in a household
    child_count = sum(child),
    # Create a variable which is the sum of the number of non-relatives in the household
    NONRELATIVE_count = sum(RELSHIPP_TYPE),
    # Create a variable that is the sum of roommates in a household
    roommate_count = sum(roommate.flag),
    # Create a variable which denotes the presence of subfamilies for a household.
    SFN.num = sum(SFN),
    # Create a variable which denotes the total number of subfamilies in a household.
    SFN.max = max(SFN)
  ) |> 
  ungroup() |> 
  mutate(
  # Create a variable that is a household flag for whether or not a household has 
  # Children. 
   child_flag = case_when(
      child_count > 0 ~ "1",
      child_count == 0 ~ "0",
      .default = "0"
    ),
   # Create a household flag for whether or not the household contains a subfamily.
   SFN.flag = if_else(SFN.num > 0, 1, 0),
   # Create a household flag for presence of a non-relative in the household.
   NONRELATIVE.flag = if_else(NONRELATIVE_count > 0, 1, 0)
  ) |> 
  mutate(
    # Non-multigenerational household WITH at least one (1) subfamily WITH at least one (1) child
    subset.flag.1 = case_when(
      MULTG == 1 & SFN.flag > 0 & child_flag > 0 ~ 1,
      .default = 0
    ),
    # Multigenerational households WITH at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.2 = case_when(
      MULTG == 2 & SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    ),
    # Households with at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.3 = case_when(
      SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    )
  )

#Check to make sure all RPAs have been included in the PUMA-RPA Crosswalk.
if (length(unique(pums_data$rpa_acr)) != 13){
  print("STOP! Check the PUMA - RPA Crosswalk for MVC and NPEDC.")
} else{
  print("Proceed!")
}

```

# 2.0 Check Size of Subsets Being Used to Create New Households and Generate Estimates of the Number of New Households Created by Splitting Households.
```{r}
#===============================================================================
# -.1 Calculate the number of non-multigenerational households with children with at least one subfamily. Estimate the number of new households created by splitting subfamilies into independent household units. A household with one subfamily will become two households. A household with two subfamilies will become three households. And so on and so forth.
subset.1 <- pums_data |> 
  # Filter for a single household row and non-GQ households.
  filter(SPORDER == 1 & TYPEHUGQ == 1) |> 
  group_by(
    subset.flag.1,
    SFN.max
  ) |> 
  # Summarize the number of households.
  summarise(
   hhds = sum(WGTP)   
  ) |> 
  ungroup() |>
  # FIlter for the first subset of households described above.
  filter(subset.flag.1 == 1) |> 
  mutate(
    new.hhds = case_when(
      SFN.max == 1 ~ hhds*2,
      SFN.max == 2 ~ hhds*3,
      SFN.max == 3 ~ hhds*4,
      SFN.max == 4 ~ hhds*5,
      .default = hhds
    ),
    new.hhds = new.hhds - hhds
  )

# Printing the sum of new households slated to be created by splitting up households in subset one.
print(paste0("Splitting non-multigenerational households with children, with at least one subfamily will create ", sum(subset.1$new.hhds), " new households."))

#===============================================================================
# -.2 Calculate the number of multigenerational households with children with at least one subfamily which are overcrowded (> 2.0 persons per bedroom). Estimate the number of new households created by splitting subfamilies into independent household units. A household with one subfamily will become two households. A household with two subfamilies will become three households. And so on and so forth.
subset.2 <- pums_data |> 
  # Filter for a single household row and non-GQ households.
  filter(SPORDER == 1 & TYPEHUGQ == 1) |> 
  group_by(
    subset.flag.2,
    SFN.max
  ) |> 
  # Summarize the number of households.
  summarise(
   hhds = sum(WGTP)   
  ) |> 
  ungroup() |> 
  # Filter for the second subset of households, described above.
  filter(subset.flag.2 == 1) |> 
  mutate(
    new.hhds = case_when(
      SFN.max == 1 ~ hhds*2,
      SFN.max == 2 ~ hhds*3,
      SFN.max == 3 ~ hhds*4,
      SFN.max == 4 ~ hhds*5,
      .default = hhds
    ),
    new.hhds = new.hhds - hhds
  )

# Printing the sum of new households slated to be created by splitting up households in subset two.
print(paste0("Splitting multigenerational households with children, with at least one subfamily, and which are overcrowded will create ", sum(subset.2$new.hhds), " new households."))

# Printing the sum of new households slated to be created by splitting up households in subset one and subset two.
print(paste0("The housheold splitting process will generate ", sum(subset.1$new.hhds) + sum(subset.2$new.hhds), " new households overall."))
```

# 3.0 Seperate Households - Redefine SERIALNO to separate subfamilies into separate households
```{r}
# Create a new SERIALNO variable that represents subfamilies and original households as distinct households.
pums_data.adj <- pums_data |> 
  mutate(
    SERIALNO.adj = case_when(
      # First Subset
      SFN == 0 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.og"),
      SFN > 0 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.adj"),
      # Second Subset
      SFN == 0 & subset.flag.2 == 1 ~ paste0(SERIALNO, ".2.og"),
      SFN > 0 & subset.flag.2 == 1 ~ paste0(SERIALNO, ".2.adj"),
      # Default to original SERIALNO for all other households.
      .default = SERIALNO
    ),
    og.flag = case_when(
      # Flag for original household of of subsetted groups
      # First Subset
      SFN == 0 & subset.flag.1 == 1 ~ "1",
      # Second Subset
      SFN == 0 & subset.flag.2 == 1 ~ "2",
      .default = "0"
    ),
    adj.flag = case_when(
      # Flag for the adjusted household of the subsetted groups
      # First Subset
      SFN > 0 & subset.flag.1 == 1 ~ "1",
      #Second Subset
      SFN > 0 & subset.flag.2 == 1 ~ "2",
      .default = "0"
    ),
    # Create a row ID number to loop through later.
    ID = row_number()
  )

```

# 3.2 Redefine SPORDER and Relationship Variables
```{r}

pums_data.adj.test <- pums_data.adj |>
  group_by(SERIALNO.adj) |> 
  mutate(
    SPORDER.adj = rank(ID, na.last = TRUE, ties.method = "first")
  ) |> 
  ungroup()

test.df <- pums_data.adj.test |> 
  filter(
    SERIALNO == "2017000008507"
  )

```

# 3.3 Re-create households variables for split households
```{r}
pums_data.adj <- pums_data.adj |> 
  group_by(
    SERIALNO.adj
  ) |> 
  mutate(
    
  ) |> 
  ungroup()
```

# 3.3 QA/QC - Check Split Households are Equal to 
```{r}

subset.1.test <- pums_data.adj |> 
  filter(
    subset.flag.1 == 1
  )

print(sum(subset.1.test$WGTP))

subset.2.test <- pums_data.adj |> 
  filter(
    subset.flag.2 == 1
  )

```

# 4.0 Calculate Headship Rates
```{r}
```

# 5.0 Compare Split Household Headship Rates to Current PUMS Vintage Headships Rates
```{r}
```


