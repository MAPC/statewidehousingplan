---
title: "01.1_HeadshipRate.Scenario.Development"
format: html
editor: visual
---

# 0.0 Setup - Define helper functions, set knitr path, load necessary packages, set muni data keys

# 0.1 - Set knitr path + root for inputs

```{r}
#Use when Rproject is open
#root <- '../../../../Data/Working/Regional_Control_Totals/'

# Base root. Toggle between S: and K: drive depending on mapped paths on your computer
base <- "K:/DataServices/Projects/Current_Projects/"
# base <- "S:/Network Shares/K Drive/DataServices/Projects/Current_Projects/"

#General K drive filepath
root <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/Regional_Control_Totals/")

# Reweighter files path
rwt_path <- paste0(base, "Housing/StatewideHousingPlan/04_Analysis/Data/Working/Reweighter/")

#PUMS K drive filepath
pums_path <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/ipums_2021/")

#Set output filepath
output_path <- paste0(base, "/Housing/StatewideHousingPlan/04_Analysis/Data/Working/PUMS/outputs/")

#Set knitr path
knitr::opts_knit$set(root.dir = pums_path)
```

# 0.2 - Set package dependencies, set environment, set up data keys

```{r}
library(tidycensus)
library(tidyverse)
library(data.table)
library(mapcdatakeys)
library(janitor)
library(readxl)
library(here)

# Remove scientific notation
options(scipen = 999)
# Set random seed
set.seed(351)

# Load Libraries for PUMS Analysis and PUMS API query functions
# Sets seed and removes scientific notation
source(here("PUMS_Analysis/PUMS_Helper_Functions.R"))
# source("C:/Project_Work/statewidehousingplan/PUMS_Analysis/PUMS_Helper_Functions.R")

# Load PUMA x RPA Crosswalk
xw <- read.csv(paste0(rwt_path, "PUMS_data/PUMA10_RPA_crosswalk.csv")) |> 
  mutate(PUMA = str_pad(PUMA, 5, "left", pad = 0))

```

# 1.0 - Load and process PUMS Data

NOTE: We use the CPI deflator time series to adjust PUMS income to 2013 dollars (for UrbanSim). ACS uses the Consumer Price Index for All Urban Consumers Retroactive Series (R-CPI-U-RS, details here: <https://www.bls.gov/cpi/research-series/r-cpi-u-rs-home.htm>) as opposed to the ASEC/Census which uses C-CPI-U (details here: [*https://www.census.gov/topics/income-poverty/income/guidance/current-vs-constant-dollars.html*](https://www.census.gov/topics/income-poverty/income/guidance/current-vs-constant-dollars.html){.uri}*)*

```{r}
# Set PUMS vintage final year for {tidycensus} API query.
vintage <- 2021

# List of PUMS variables
variable_list <- c('RT', 'PUMA', 'ADJHSG','ADJINC','NP','TYPEHUGQ','BDSP','RMSP','CPLT','HHLDRAGEP',
                   'HHLDRRAC1P','HHLDRHISP', 'HHT', 'HHT2', 'HINCP', 'HUGCL', 'HUPAC', 'HUPAOC',
                   'HUPARC', 'LNGI', 'MULTG', 'NPF', 'NPP', 'NR','NRC', 'PARTNER', 'PSF','R18',
                   'AGEP','RELSHIPP','RAC1P','OC','SFN','SFR','TEN', "SEX", "PINCP", "ESR",
                   'GRPIP', 'OCPIP', 'MV', 'SCHL', 'HISP', 'WKHP')

# SEMP bottom coding has changed from $1 to $4 like WAGP

# Query {tidycensus} for 2017-2021 5-Year PUMS data
pums_data <- pums_query(var.list = variable_list, yr = vintage, srvy = "acs5") |>
  # General Data Cleaning
  mutate(
    # Generate five-year age groupings to match UMDI population projections data.
    ageCAT6 = cut(AGEP, breaks = c(-Inf, seq(4, 84, 5), Inf), labels = 1:18),
    # Renaming the 5-year age group variable.
    AgeCat = ageCAT6,
    # Generate a custom age grouping
    # Levels are (0) 0-14; (4) 15 to 19; (5) 20 to 24; (6) 25 to 34; (7) 35 to 44; (8) 45 to 54; (9) 55 to 64 (10) 65 to 74 (11) 75+
    PAGEC2 = cut(AGEP, breaks = c(-Inf, 14, 19, 24, 34, 44, 54, 64, 74, 79, 84, Inf), labels = c(0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)),
    # Generate ten-year age groupings 
    # ageCAT4 is the 2020 decennial census age breaks for age of householder - used for 2020 base year control total reweighter targets
    ageCAT4 = case_when(
      AGEP %in% 15:24 ~ 1,
      AGEP %in% 25:34 ~ 2,
      AGEP %in% 35:44 ~ 3,
      AGEP %in% 45:54 ~ 4,
      AGEP %in% 55:59 ~ 5,
      AGEP %in% 60:64 ~ 6,
      AGEP %in% 65:74 ~ 7,
      AGEP %in% 75:84 ~ 8,
      AGEP >= 85 ~ 9
    ), 
    # Creates a tenure grouping for reweighter file:
    tenure = case_when(# Owned with a mortgage or free and clear -> "1"
      TEN %in% c('1', '2') ~ 1,
      # Rented or occupied without payment of rent -> "2"
      TEN %in% c('3', '4') ~ 2,
      .default = 999
    ), 
    # Creates a tenure grouping for:
    TEN_Group = case_when(# Owned with a mortgage or free and clear -> "Own"
      TEN %in% c('1', '2') ~ "Own",
      # Rented or occupied without payment of rent -> "Rent"
      TEN %in% c('3', '4') ~ "Rent",
      .default = "Unknown"
    ), 
    # Counts as Worker
    # NOTE - Categories are:
    # (0) under 16 or not in labor force
    # (1) in labor force or non-civilian worker
    worker = case_when(
      (ESR == "b" | ESR == 6) ~ 0,
      (ESR == 1 | ESR == 2 | ESR == 3 | ESR == 4 | ESR == 5) ~ 1,
      is.na(ESR) ~ 0
    ),
    # Categorizing Civilian Labor Force or not
    # NOTE: Categories ar
    # (0) under 16 or non-civilian
    # (1) in labor force
    # (2) not in labor force
    lf = case_when(
      ESR == "b" | ESR == 4 | ESR == 5  ~ 0,
      ESR == 1 | ESR == 2 | ESR == 3  ~ 1,
      ESR == 6 ~ 2,
      is.na(ESR) ~ 0
    ),
    # Counts as person
    person = case_when(
      SPORDER != 0 ~ 1,
      SPORDER == 0 ~ 0
    ),
    # Create a household flag for whether there is a child in a household.
    child = case_when(
      AGEP < 18 ~ 1,
      AGEP >= 18 ~ 0,
      .default = 0
    ),
    # Householder Race Groupings.
    RACE_Group = case_when(
      RAC1P == "1" ~ "White Alone",
      RAC1P == "2" ~ "Black or African American Alone",
      RAC1P %in% c("3", "4", "5") ~ "AIAN Alone",
      RAC1P == "6" ~ "Asian Alone",
      RAC1P == "7" ~ "NHPI Alone",
      RAC1P == "8" ~ "Some Other Race Alone",
      RAC1P == "9" ~ "Two or More Races Alone",
      .default = "Unknown"
    ),
    # Householder Hispanic/Non-Hispanic Groupings
    HISP_Group = case_when(
      HISP == "01" ~ "Non-Hispanic",
      HISP != "01" ~ "Hispanic",
      .default = "Unknown"
    ),
    # Educational Attainment Groupings
    # NOTE - Categories are:
    # (1) High school degree or less
    # (2) Associate's degree or some college
    # (3) Bachelor's
    # (4) MA or higher
    SCHL = as.numeric(SCHL),
    eduattn = case_when(
      SCHL <= 17 ~ 1,
      SCHL %in% 18:20 ~ 2,
      SCHL == 21 ~ 3,
      SCHL >= 22 ~ 4,
      is.na(SCHL) ~ 0,
      .default = 0
    ),
    # Create a grouping variable for types of relationships to the householder.
    RELSHIPP_TYPE = case_when(
      # 1 indicates a person in a household that is related in some way to the householder.
      RELSHIPP %in% c(21,22,23,24,25,26,27,28,29,30,31,32,33) ~ 0,
      # 2 indicates a person in a household unrelated to the householder.
      RELSHIPP %in% c(34,35,36) ~ 1,
      # Set a default flag for householders.
      .default = 0
    ),
    # Create a "Studio/Non-Defined Bedroom" variable to denote where households do
    # not have a bedroom number.
    studio_flag = case_when(
      BDSP == 0 ~ "Studio/No Defined Bedroom",
      BDSP != 0 ~ "Defined Bedroom",
      .default = "Unknown"
    ),
    # Redefine BDSP to label studios/non-defined bedroom units as One-Bedrooms
    # For purpose of calculating the number of people per bedrooms.
    BDSP = if_else(BDSP == 0, 1, BDSP),
    # Calculate the number of people per bedroom in a housing unit.
    PPB = NP/BDSP,
    # Categorize each housing unit as overcrowded or not based on PPB.
    overcrowded.ppb = case_when(
      PPB > 2.0 ~ "1",
      PPB <= 2.0 ~ "0"
    ),
    # Convert SFN into a numeric column. Introduces NAs for people not in subfamilies
    SFN = as.numeric(SFN),
    # Replace the NA for non-subfamily members with 0.
    SFN = replace_na(SFN, 0)
  ) |>
  # Creating household flags for person variables.
  group_by(SERIALNO) |> 
  mutate(
    # Create a variable which denotes the presence of subfamilies for a household.
    SFN.num = sum(SFN),
    # Create a variable which denotes the total number of subfamilies in a household.
    SFN.max = max(SFN),
    # Sum the total number of workers in the household
    Worker_Total = sum(worker),
    # Sum the total number of children in the household
    Child_Total = sum(child)
  ) |> 
  ungroup() |> 
  mutate(
  # Create a variable that is a household flag for whether or not a household has children. 
   child_flag = case_when(
      Child_Total > 0 ~ "1",
      Child_Total == 0 ~ "0",
      .default = "0"
    ),
   # Create a household flag for whether or not the household contains a subfamily.
   SFN.flag = if_else(SFN.num > 0, 1, 0),
   # Categorizing worker categories:
   # (0) no workers
   # (1) one worker
   # (2) two workers
   # (3) three or more workers
   WRKHH = case_when(
     Worker_Total == 0 ~ 0,
     Worker_Total == 1 ~ 1,
     Worker_Total == 2 ~ 2,
     Worker_Total >= 3 ~ 3
    ),
  # Determine if person is not hhder vs hhder of:
  # (0) No Workers
  # (1) One Worker 
  # (2) Two Workers
  # (3) Three or more workers
   HHder = case_when(
     SPORDER == 1 & WRKHH == 0 ~ 0,
     SPORDER == 1 & WRKHH == 1 ~ 1,
     SPORDER == 1 & WRKHH == 2 ~ 2,
     SPORDER == 1 & WRKHH == 3 ~ 3,
     SPORDER > 1 ~ 99
   ),
   # Determine what type of household the person is heading or not heading:
   # (1) Householder of Household with Children
   # (2) Non-Householder in a Household with Children
   # (3) Householder of a Household with Multiple Adults and no children
   # (4) Non-Householder in a Household with no children
   # (5) Householder of a Single Person Household
   HHtype = case_when(
     Child_Total >= 1 & NP > 1 & HHder != 99 ~ 1,
     Child_Total >= 1 & NP > 1 & HHder == 99 ~ 2,
     Child_Total == 0 & NP > 1 & HHder != 99 ~ 3,
     Child_Total == 0 & NP > 1 & HHder == 99 ~ 4,
     NP == 1 & HHder != 99 ~ 5
   )
  ) |> 
  mutate(
    # Non-multigenerational household WITH at least one (1) subfamily WITH at least one (1) child
    subset.flag.1 = case_when(
      MULTG == 1 & SFN.flag > 0 & child_flag > 0 ~ 1,
      .default = 0
    ),
    # Multigenerational households WITH at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.2 = case_when(
      MULTG == 2 & SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    ),
    # Households with at least one (1) subfamily WITH at least one (1) child AND is overcrowded
    subset.flag.3 = case_when(
      SFN.flag > 0 & child_flag > 0 & overcrowded.ppb == "1" ~ 1,
      .default = 0
    )
  )

```

# 2.0 Check Size of Subsets Being Used to Create New Households and Generate Estimates of the Number of New Households Created by Splitting Households.

```{r}
#===============================================================================
# -.1 Calculate the number of non-multigenerational households with children with at least one subfamily. Estimate the number of new households created by splitting subfamilies into independent household units. A household with one subfamily will become two households. A household with two subfamilies will become three households. And so on and so forth.
subset.1 <- pums_data |> 
  # Filter for a single household row and non-GQ households.
  filter(SPORDER == 1 & TYPEHUGQ == 1) |> 
  group_by(
    subset.flag.1,
    SFN.max
  ) |> 
  # Summarize the number of households.
  summarise(
   hhds = sum(WGTP)   
  ) |> 
  ungroup() |>
  # Filter for the first subset of households described above.
  filter(subset.flag.1 == 1) |> 
  mutate(
    new.hhds = case_when(
      SFN.max == 1 ~ hhds*2,
      SFN.max == 2 ~ hhds*3,
      SFN.max == 3 ~ hhds*4,
      SFN.max == 4 ~ hhds*5,
      .default = hhds
    ),
    new.hhds = new.hhds - hhds
  )

# Printing the sum of new households slated to be created by splitting up households in subset one.
print(paste0("Splitting non-multigenerational households with children, with at least one subfamily will create ", sum(subset.1$new.hhds), " new households."))

#===============================================================================
# -.2 Calculate the number of multigenerational households with children with at least one subfamily which are overcrowded (> 2.0 persons per bedroom). Estimate the number of new households created by splitting subfamilies into independent household units. A household with one subfamily will become two households. A household with two subfamilies will become three households. And so on and so forth.
subset.2 <- pums_data |> 
  # Filter for a single household row and non-GQ households.
  filter(SPORDER == 1 & TYPEHUGQ == 1) |> 
  group_by(
    subset.flag.2,
    SFN.max
  ) |> 
  # Summarize the number of households.
  summarise(
   hhds = sum(WGTP)   
  ) |> 
  ungroup() |> 
  # Filter for the second subset of households, described above.
  filter(subset.flag.2 == 1) |> 
  mutate(
    new.hhds = case_when(
      SFN.max == 1 ~ hhds*2,
      SFN.max == 2 ~ hhds*3,
      SFN.max == 3 ~ hhds*4,
      SFN.max == 4 ~ hhds*5,
      .default = hhds
    ),
    new.hhds = new.hhds - hhds
  )

# Printing the sum of new households slated to be created by splitting up households in subset two.
print(paste0("Splitting multigenerational households with children, with at least one subfamily, and which are overcrowded will create ", sum(subset.2$new.hhds), " new households."))

# Printing the sum of new households slated to be created by splitting up households in subset one and subset two.
print(paste0("The housheold splitting process will generate ", sum(subset.1$new.hhds) + sum(subset.2$new.hhds), " new households overall."))
```

# 3.0 Seperate Households - Redefine SERIALNO to separate subfamilies into separate households

```{r}
# Create a new SERIALNO variable that represents subfamilies and original households as distinct households.
pums_data.adj <- pums_data |> 
  mutate(
    SERIALNO.adj = case_when(
      # First Subset
      SFN == 0 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.og"),
      SFN == 1 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf1.adj"),
      SFN == 2 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf2.adj"),
      SFN == 3 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf3.adj"),
      SFN >= 4 & subset.flag.1 == 1 ~ paste0(SERIALNO,".1.sf4.adj"),
      # Second Subset
      SFN == 0 & subset.flag.2 == 1 ~ paste0(SERIALNO, ".2.og"),
      SFN == 1 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf1.adj"),
      SFN == 2 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf2.adj"),
      SFN == 3 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf3.adj"),
      SFN >= 4 & subset.flag.2 == 1 ~ paste0(SERIALNO,".2.sf4.adj"),
      # Default to original SERIALNO for all other households.
      .default = SERIALNO
    ),
    og.flag = case_when(
      # Flag for original household of of subsetted groups
      # First Subset
      SFN == 0 & subset.flag.1 == 1 ~ "1",
      # Second Subset
      SFN == 0 & subset.flag.2 == 1 ~ "2",
      .default = "0"
    ),
    adj.flag = case_when(
      # Flag for the adjusted household of the subsetted groups
      # First Subset
      SFN > 0 & subset.flag.1 == 1 ~ "1",
      #Second Subset
      SFN > 0 & subset.flag.2 == 1 ~ "2",
      .default = "0"
    ),
    adj.flag.2 = case_when(
      # Flag for the adjusted household of the subsetted groups
      # First Subset
      SFN > 0 & subset.flag.1 == 1 ~ "1",
      #Second Subset
      SFN > 0 & subset.flag.2 == 1 ~ "1",
      .default = "0"
    )
  )

```

# 3.1 Reorder Persons in Households to be Split

```{r}
# Reordering persons in the households to be split.
# Subset of households that will not be split that do not need to be reordered
pums_data.adj.og <- pums_data.adj |> 
  filter(adj.flag.2 == "0")

# Subset of households that WILL be split and need to be reordered within their new household.
pums_data.adj.adj <- pums_data.adj |> 
  filter(adj.flag.2 == "1") |> 
  group_by(SERIALNO.adj) |> 
  dplyr::arrange(desc(AGEP), .by_group = TRUE) |> 
  ungroup()

# To redefine the person order within a household, we need to make sure the people in the households to be split are at least sort of logically ordered. I am assuming that the oldest person (as captured by AGEP) is the "head" (SPORDER == 1) of the household. We do not want children to head a household in which they have a parent, which they should because that is the definition of a subfamily when they have children.

# Rebinding the pums data subsets with the people in the households to be split properly arranged by age.
pums_data.adj <- rbind(pums_data.adj.og, pums_data.adj.adj)

# Removing the interim subsets I no longer need.
rm(pums_data.adj.og, pums_data.adj.adj)
```

# 3.2 Redefine SPORDER and Relationship Variables

```{r}
# Redefine SPORDER and Relationship Variables in the pums_data.adj dataframe
pums_data.adj <- pums_data.adj |>
  mutate(
    # Create a row ID number to loop through later.
    ID = row_number()
  ) |> 
  group_by(SERIALNO.adj) |> 
  mutate(
    # Create a new SPORDER variable based on the order of people in the new households (if they are split into new households).
    SPORDER.adj = rank(ID, na.last = TRUE, ties.method = "first")
  ) |> 
  ungroup() |> 
  mutate(
    # Adjusting the RELSHIPP variable to reflect the new SPORDER for split households.
    RELSHIPP.adj = case_when(
      SPORDER.adj == 1 ~ "20",
      SPORDER.adj != 1 & adj.flag == "0" ~ RELSHIPP,
      SPORDER.adj != 1 & adj.flag %in% c("1","2") & SFR %in% c("1","2","3") ~ "21.22.23.24",
      SPORDER.adj != 1 & adj.flag %in% c("1","2") & SFR %in% c("4","5","6") ~ "25.26.27.35",
      .default = "Something's Wrong!"
    ),
    # Adjusting the Subfamily Number variable to reflect having split subfamilies out from their original household.
    SFN.adj = case_when(
      adj.flag %in% c("1","2") ~ 0,
      .default = SFN
    ),
    # Adjusting the Subfamily Relationship variable to reflect having split subfamilies out from their original household.
    SFR.adj = case_when(
      adj.flag %in% c("1","2") ~ "b",
      .default = SFR
    )
  )

# List of assumptions:
# 1. Cant determine the kind of spouse or child non-reference persons are in the new, split households. Could distinguish same or opposite sex spousal relationship with "SEX" variable added to the PUMS data.
# 2. Can we use RELSHIPP to help us be more correct? What about for people who are non-relatives?

```

# 3.3 Re-create households variables for split households

```{r}
# Re-create households variables for split households
pums_data.adj <- pums_data.adj |> 
  mutate(
    # Counts as Worker
    # NOTE: Categories are:
    # (0) under 16 or not in labor force
    # (1) in labor force or non-civilian worker
    worker = case_when(
      (ESR == "b" | ESR == 6) ~ 0,
      (ESR == 1 | ESR == 2 | ESR == 3 | ESR == 4 | ESR == 5) ~ 1,
      is.na(ESR) ~ 0
    ),
    # Determine if case counts as person
    person = case_when(
      SPORDER != 0 ~ 1,
      SPORDER == 0 ~ 0
    ),
    # Determine if case counts as child
    child = case_when(
      AGEP < 18 ~ 1,
      AGEP >= 18 ~ 0
    )
  ) |> 
  group_by(SERIALNO.adj) |> 
  mutate(
    # Re generate the NP (number of persons in a household) variable
    NP.adj = n(),
    # Re generate the HINCP (household income) variable
    HINCP.adj = sum(PINCP),
    # Adjust income data to 2021 dollars
    HINCP.adj.2021USD = as.numeric(HINCP.adj)*as.numeric(ADJINC),
    # Sum the total number of workers in the household
    Worker_Total = sum(worker),
    # Sum the total number of children in the household
    Child_Total = sum(child)
  ) |> 
  ungroup() |> 
  mutate(
    # Categorizing Household Size
    size = case_when(
      NP.adj == 1 ~ 1,
      NP.adj == 2 ~ 2,
      NP.adj == 3 ~ 3,
      NP.adj == 4 ~ 4,
      NP.adj == 5 ~ 5,
      NP.adj == 6 ~ 6,
      NP.adj >= 7 ~ 7,
    ),
    # Categorizing worker categories:
    # (0) no workers
    # (1) one worker
    # (2) two workers
    # (3) three or more workers
    WRKHH = case_when(
      Worker_Total == 0 ~ 0,
      Worker_Total == 1 ~ 1,
      Worker_Total == 2 ~ 2,
      Worker_Total >= 3 ~ 3
      ),
    # Determine if person is not hhder vs hhder of 
    # (0) No workers
    # (1) One worker
    # (2) Two workers
    # (3) Three or more workers
    HHder = case_when(
      SPORDER.adj == 1 & WRKHH == 0 ~ 0,
      SPORDER.adj == 1 & WRKHH == 1 ~ 1,
      SPORDER.adj == 1 & WRKHH == 2 ~ 2,
      SPORDER.adj == 1 & WRKHH == 3 ~ 3,
      SPORDER.adj > 1 ~ 99
    ),
    # Determine what type of household the person is heading or not heading 
    # (1) Householder of Household with Children
    # (2) Non-Householder in a Household with Children
    # (3) Householder of a Household with Multiple Adults and no children
    # (4) Non-Householder in a Household with no children 
    # (5) Householder of a Single Person Household
    HHtype = case_when(
      Child_Total >= 1 & NP.adj > 1 & HHder != 99 ~ 1,
      Child_Total >= 1 & NP.adj > 1 & HHder == 99 ~ 2,
      Child_Total == 0 & NP.adj > 1 & HHder != 99 ~ 3,
      Child_Total == 0 & NP.adj > 1 & HHder == 99 ~ 4,
      NP.adj == 1 & HHder != 99 ~ 5
    )
  )

# List of meaningful recalculations:
# 1. NP - summing the number of persons present in original and split subfamily households
# 2. HINCP - summing the individual incomes of household members to generate a new household income.
# 3. HHDERAGEP - Redefine as for split subfamily households.
# 4. PPB - recalculate the overcrowding indicator based on the new number of people in the household. CAVEAT - we're not updating the housing unit characteristics to reflect a change in unit type. We assume the split subfamilies will not intentionally become overcrowded and, therefore, a smaller numerator with constant denominator calculation will reflect, essentially, their reality. 
# 5. Calculations of number of children in a household - sum the number of children in each housing unit to reflect the new compositions of households.
# 6. Calculation of household type - redefine the household type of original and split subfamily households to reflect their new composition. This could mean a household with children will become a household without children (with 2+ adults) and a household with children (and vice versa, depending on the composition of the split subfamily).
# zzz. MULTG - splitting 

# List of assumptions:
# 1. Tenure remains the same. A split subfamily lived in a house owned by the householder, we assume they've also purchased a home. If they were in a rental household, they rent.
# 2. Number of rooms in the house remain the same, even if the number of rooms and bedrooms doesn't necessarily make sense for the split subfamily household. Easier to not make assumptions about the types of housing they rent or buy after splitting out.
# 3. Household income is the sum of incomes of the individuals within the household. Incomes are recalculated for the original household and the new split subfamily household.
# 4. 
```

# 3.4 QA/QC - Check Split Households are Equal to The Number of Households We Expect to Be Split

```{r}
#===============================================================================
# Analyze Subset #1
# Filter for the subset of non-subfamily members from the split household (the "original" household).
subset.1.og.test <- pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.1 == 1 & adj.flag == 0)

# Filter for the subset of subfamily members from the split household (the "original" household).
subset.1.adj.test <- pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.1 == 1 & adj.flag == 1)

# Print the number of household created by the household split code for Subset #1.
print(sum(subset.1.adj.test$WGTP))

#===============================================================================
# Analyze Subset #2
# Filter for the subset of non-subfamily members from the split household (the "original" household).
subset.2.og.test <- pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.2 == 1 & adj.flag == 0)

# Filter for the subset of subfamily members from the split household (the "original" household).
subset.2.adj.test <- pums_data.adj |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1 & subset.flag.2 == 1 & adj.flag == 2)

# Print the number of households created by the household split code for Subset #2.
print(sum(subset.2.adj.test$WGTP))

# Print the sum of households created by the household split code for both subsets #1 and #2.
print(sum(sum(subset.1.adj.test$WGTP), sum(subset.2.adj.test$WGTP)))

# Compare the total number of households in subsets #1 and #2 to the number of households created by the household split. If they are not equivalent, a warning message will be printed. If they are, an affirmative will be printed.
if(sum(sum(subset.1$new.hhds), sum(subset.2$new.hhds)) != sum(sum(subset.1.adj.test$WGTP), sum(subset.2.adj.test$WGTP))){
  print("STOP! The number of households identified in the earlier code should match what is produced after splitting households!")
} else{
  print("Proceed!")
}

```

# 3.5 Create PUMS Extract for Reweighter
```{r}
# Creating the PUMS data extract for Scenario 2
pums_data.adj.rwt <- pums_data.adj |> 
  left_join(
    xw,
    by = c("PUMA"),
    relationship = "many-to-many"
  )

# Write PUMS extract to reweighter input folder for Scenario 2
write.csv(
  pums_data.adj.rwt,
  file = paste0(rwt_path, '/PUMS_data/PUMS2021.Split_formatted.csv'),
  row.names = FALSE
)

```

# 3.6 Analysis of Subset Households

```{r}
# Full dataframe of subset households.
subset.adj.test <- bind_rows(subset.1.adj.test, subset.2.adj.test) |> 
  # Join the PUMA to RPA ceosswalk to the PUMS data
  left_join(
    xw,
    by = c('PUMA')
  ) |> 
  mutate(
    WAGPALLC_US = 
      cut(
        HINCP.adj.2021USD,
        breaks = c(-Inf, 35000, 75000, 125000, 225000, Inf),
        labels = c("1", "2", "3", "4", "5")
      )
  )
  
#Households by RPA
tbl.1 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(rpa_acr) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

# Households by Household Type
tbl.2 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    HHtype
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#Households by Household Types and RPA
tbl.3 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    rpa_acr,
    HHtype
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#Households by Household Size
tbl.4 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    NP.adj
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#Households by Presence of Children
tbl.5 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    Child_Total
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#Households by Household Size and Presence of Children
tbl.6 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    NP.adj,
    Child_Total
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#Households by Household Income
tbl.7 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    WAGPALLC_US
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#Households by Householder Age
tbl.8 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    ageCAT6
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#Households by the Number of Workers in the Household
tbl.9 <- subset.adj.test |> 
  filter(SPORDER.adj == 1 & TYPEHUGQ == 1) |> 
  group_by(
    Worker_Total
  ) |> 
  summarise(
    hhds = sum(WGTP)
  ) |> 
  ungroup()

#============
# TODO:
# 4. Race/Eth
# 5. Educational Attainment
```

# 4.0 Calculate Headship Rates for Split Households PUMS

```{r}
# Generating headship rates by RPA and 5-year age group for the ACS 2017-2022 PUMS
headship_rates.split <- pums_data.adj |> 
  # Join the PUMA to RPA crosswalk to the PUMS data
  left_join(
    xw,
    by = c('PUMA')
  ) |>
  # Includes only observations for people in households (omits GQ)                       
  filter(TYPEHUGQ == "1") |> 
  # Groups by variables in the dataframe necessary to getting the granularity of
  # data we're interested in.
  group_by(rpa_acr, ageCAT6) |> 
  # Computes the weighted sum of individuals in each HH type category by the groups
  # assigned above.
  count(var = HHtype, wt = WGTP)  |>
  ungroup() |> 
  group_by(rpa_acr, ageCAT6) |>
  # Recodes factor variables as the categories they represent.
  # Converts numbers into frequencies.                       
  mutate(
    var = case_when(
      var == 1 ~ "hhderchild",
      var == 2 ~ "nothhderchild",
      var == 3 ~ "hhdernochild",
      var == 4 ~ "nothhdernochild",
      var == 5 ~ "single"),
    freq = (n/sum(n))) |> 
  # Removes the level of aggregation set earlier by group_by()
  ungroup() |> 
  select(
    -c(n)
  ) |> 
  dplyr::rename(
    freq.split = freq
  ) |> 
  mutate(
    ageCAT6 = as.factor(ageCAT6)
  )

# Generating headship rates by RPA and 5-year age group for the ACS 2017-2022 PUMS
tenure_rates.split <- pums_data.adj |> 
  # Join the PUMA to RPA crosswalk to the PUMS data
  left_join(
    xw,
    by = c('PUMA')
  ) |>
  # Includes only observations for people in households (omits GQ)                       
  filter(SPORDER.adj == 1 & TYPEHUGQ == "1") |> 
  # Groups by variables in the dataframe necessary to getting the granularity of
  # data we're interested in.
  group_by(rpa_acr, ageCAT6) |> 
  # Computes the weighted sum of individuals in each HH type category by the groups
  # assigned above.
  count(var = TEN_Group, wt = WGTP)  |>
  ungroup() |> 
  group_by(rpa_acr, ageCAT6) |>
  # Converts numbers into frequencies.                       
  mutate(
    freq = (n/sum(n))
  ) |> 
  # Removes the level of aggregation set earlier by group_by()
  ungroup() |> 
  select(
    -c(n)
  ) |> 
  dplyr::rename(
    freq.split = freq
  ) |> 
  mutate(
    ageCAT6 = as.factor(ageCAT6)
  )

# QC Check - determine if the frequencies in each RP, Age Group crosstab add to 1
hr_check <- headship_rates.split |> 
  group_by(
    rpa_acr,
    ageCAT6
  ) |> 
  summarise(
    freq_check = sum(freq.split)
  ) |> 
  ungroup() |> 
  mutate(
    flag = ifelse(freq_check != 1, 1, 0)
  )

# QC Check - determine if the frequencies in each Tenure, Age Group crosstab add to 1
ten_check <- tenure_rates.split |> 
  group_by(
    rpa_acr,
    ageCAT6
  ) |> 
  summarise(
    freq_check = sum(freq.split)
  ) |> 
  ungroup() |> 
  mutate(
    flag = ifelse(freq_check != 1, 1, 0)
  )

# Print statement to verify w/in headhship groups that the numbers all add up accordingly.
if (sum(hr_check$flag) > 0 | sum(ten_check$flag) > 0){
  # Print when numbers are incorrect.
  print("STOP! Check headship rate calculations!")
} else{
  #Print when numbers are correct.
  print("Proceed!")
  
  # Remove QC files.
  rm(hr_check, ten_check)
}

# Export headship rates
write.csv(
  headship_rates.split,
  paste0(rwt_path,"Headship_rates/headship.rates.1721_household.split.csv"),
  row.names = FALSE
)

# Export tenure rates
write.csv(
  tenure_rates.split,
  paste0(rwt_path,"Headship_rates/tenure.rates.1721_household.split.csv"),
  row.names = FALSE
)

```
